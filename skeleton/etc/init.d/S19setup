#!/bin/sh
#
# setup	This script provides persistent storage to be 
#		used with an otherwise volatile ram disk file system.
#

### functions that are used in more than one init script
[ -x /etc/init.d/init_functions ] && . /etc/init.d/init_functions

# assume boot device is already mounted r/o
device_mounted=1
device_writeable=0
# other global variables
mountpoint=""
blockdevice=""
# device names for block devices
HARD_DISKS=/dev/sd[a-z][0-9]
FLASH_DISKS=/dev/mmcblk[0-9]p[0-9]
# the partition name
partition_name="NABLA"
# script name for log output
script=$(basename $0)
# main configuration file relative to config directory
config_file_path="etc/nabla.conf"
# main configuration file during operation
system_config_file="/etc/nabla.conf"
# command parameters
cmd_start="startup"
cmd_stop="shutdown"

#
# finds out if a partition is mounted writeable or read-only
# unmounted partitions will be assumed read-only
# parameter $1 = device name
#
is_partition_writeable() {
	device="$1"
	writeable=0
	attribute=`grep $device /proc/mounts | \
		awk '{ print $4 }' | \
		awk 'BEGIN{ FS="," } \
			{ for(i=0; i<$NF; i=i+1) { if ($(i+1)~"^r[ow]$") {print $(i+1);break}} }'`
	if [ "$attribute" = "rw" ]; then 
		writeable=1
	fi
	echo $writeable
}

#
# extracts the mount point of a mounted partition
# parameter $1 = device name
#
get_mountpoint() {
	device="$1"
	echo `grep $device /proc/mounts | awk '{ print $2 }'`
}

#
# finds out if a partition is mounted 
# parameter $1 = device name
#
is_partition_mounted() {
	device="$1"
	mounted=0
	mountpoint=`get_mountpoint $device`
	if [ -n "$mountpoint" ]; then 
		mounted=1
	fi
	echo $mounted
}

#
# Retrieves the partition label of a block device. 
# If the partition has no label, the GUID is used. 
# parameter $1 = device name 
#
get_partition_label() {
	device="$1"
	label=""
		uid=""
		if [ -n "${device##/dev/*}" ]; then device="/dev/$device"; fi
		for s in `blkid $device`; do
			case $s in
			UUID=*)
				uid=`expr match "$s" '.*=\"\(.*\)\"'`
				;;
			LABEL=*)
				label=`expr match "$s" '.*=\"\(.*\)\"'`
				;;
			esac
		done
	if [ -n "$label" ]; then echo "$label"; else echo "$uid"; fi
}

#
# Find partition, (re)mount it writeable, read configuration file
# The function exports the following global variables: 
#	blockdevice = path to partition device file
#	mountpoint = path the partition is mounted on
#	device_mounted = partition was mounted initially
#	device_writeable = partition was mounted writeable
#	config_directory = the directory on the partition containing the config files
# And accepts the parameter 
#	$1 = [$cmd_start,$cmd_stop] designates the transfer direction
#
setup_prepare() {
	local command="$1"
	local config_file=""
	export blockdevice=""
	# partition may not be mounted yet
	for b in $HARD_DISKS $FLASH_DISKS; do
		label=`get_partition_label $b`
		if [ "$label" = "$partition_name" ]; then
			export blockdevice=$b
			export device_mounted=`is_partition_mounted $blockdevice`
			export device_writeable=`is_partition_writeable $blockdevice`
		fi
	done
	# terminate if the partition does not exist
	if [ -z $blockdevice ]; then return 2; fi
	echo "$script:  Found $blockdevice mt=$device_mounted rw=$device_writeable"
	if [ $device_mounted -eq 1 ]; then
		export mountpoint=`get_mountpoint $blockdevice`
		if [ $device_writeable -eq 0 ]; then
			# remount partition
			mount -o remount,rw $blockdevice || return 1
			echo "$script:  Remounted $blockdevice rw"
		else
			echo "$script:  $blockdevice already mounted on $mountpoint"
		fi
	else
		# mount partition
		export mountpoint=/tmp/$partition_name
		mkdir -p $mountpoint
		mount $blockdevice $mountpoint || return 1
		echo "$script: mounted $blockdevice in $mountpoint"
	fi
	export config_directory="$mountpoint/${config_directory}"
	# config file in root file system
	config_file="$system_config_file"
	# during startup the saved (if present) file is used
	if [ $command = ${cmd_start} ] && [ -f $config_directory/$config_file_path ]; then
		config_file="$config_directory/$config_file_path"
	fi
	. $config_file
	echo "$script:  Configuration file $config_file read"
}

#
# copy from source to destination
# function parameters
#	$1 = source
#	$2 = destination
# either $source or $destination is an empty string
#
setup_copy() {
	src_directory=$1
	dst_directory=$2
	sync_directories="$NABLA_SYNC_DIRECTORIES"
	if [ -n "$sync_directories" ]; then
		for s in $sync_directories; do
			# item is a directory
			if [ -d "${src_directory}${s}" ]; then
				echo "$script:  Start syncing directory $s"
				# create $s on target filesystem
				mkdir -p "${dst_directory}${s}" || return 1
				# copy (preserve symlinks, preserve file attributes)
				cp -dp "${src_directory}${s}"/* "${dst_directory}${s}" > /dev/null 2>&1
				echo "$script:  Finished syncing directory $s"
			# item is a file
			elif [ -f "${src_directory}${s}" ]; then
				d=`dirname ${s}`
				# create $d on target filesystem
				mkdir -p "${dst_directory}${d}" || return 1
				# copy (preserve symlinks, preserve file attributes)
				cp -dp "${src_directory}${s}" "${dst_directory}${s}" > /dev/null 2>&1
				echo "$script:  Copied file $s"
			else
				echo "$script:  Missing entity $s"
			fi
		done
	fi
}

#
# backup configuration files to config directory
#
setup_copy_shutdown() {
	src_directory=""
	dst_directory=${config_directory}
	echo "$script:  Export to ${dst_directory}"
	setup_copy ${src_directory} ${dst_directory}
}

#
# restore configuration from config directory
#
setup_copy_startup() {
	src_directory=${config_directory}
	dst_directory=""
	echo "$script:  Import from ${src_directory}"
	setup_copy ${src_directory} ${dst_directory}
}

#
# fixes some things that were broken by importing files
#
setup_postprocess() {
	# replace all occurrences of default host name with configured name
	if [ -n "$NABLA_HOSTNAME" ]; then
		# replace hostname file
		echo $NABLA_HOSTNAME > /etc/hostname
		# set host name
		hostname $NABLA_HOSTNAME
		# modify hosts file
		config="/etc/hosts"
		sed "/^127\.0\.1\.1/ s/127\.0\.1\.1.*/127.0.1.1\t$NABLA_HOSTNAME/" < $config > ${config}_ 
		# cleaning up
		if [ $? -eq 0 ]; then
			rm $config && mv ${config}_ $config
		else
			rm ${config}_ 
		fi
	fi
	# modify avahi configuration
	config="/etc/avahi/avahi-daemon.conf"
	if [ -f $config ]; then
		sed "s/host-name=.*/host-name=$(hostname)/" < $config > ${config}_ 
		# cleaning up
		if [ $? -eq 0 ]; then
			rm $config && mv ${config}_ $config
		else
			rm ${config}_ 
		fi
	fi
}

#
# Restore partition's earlier state
# The function clears the following global variables: 
#	blockdevice = path to partition device file
#	mountpoint = path the partition is mounted on
#	device_mounted = partition was mounted initially
#	device_writeable = partition was mounted writeable
#	config_directory = the directory on the partition containing the config files
#
setup_finish() {
	if [ $device_mounted -eq 1 ]; then
		if [ $device_writeable -eq 0 ]; then
			# remount partition
			mount -o remount,ro $blockdevice || return 1
			echo "$script:  Remounted $blockdevice RO"
		fi
	else
		umount $blockdevice || return 1
		echo "$script:  unmounted $blockdevice from $mountpoint"
		rmdir $mountpoint
		echo "$script:  removed $mountpoint"
	fi
	export blockdevice=""
	export mountpoint=""
	export device_mounted=""
	export device_writeable=""
	export config_directory=""
}

#
# main function for "stop" or "sync" parameter of init script
#
setup_backup() {
	setup_prepare ${cmd_stop} || return 1
	setup_copy_shutdown || return 1
	setup_finish || return 1
}

#
# main function for "start" parameter of init script
#
setup_restore() {
	for i in `seq 10`; do
		setup_prepare ${cmd_start} && break
		# wait for USB subsystem if unsuccessful
		usleep 500000
	done
	if [ -z $mountpoint ]; then return 1; fi
	setup_copy_startup || return 1
	setup_postprocess || return 1
	setup_finish || return 1
}

#
# processing starts here
#

umask u+w,a+r

if [ "$1" = "start" ]; then
	echo "Restoring configuration..."
	setup_restore
	echo "Done"
elif [ "$1" = "stop" -o "$1" = "sync" ]; then
	echo "Backing up configuration..."
	setup_backup
	echo "Done"
else
	echo "Usage: $0 {start|stop|sync}"
fi
