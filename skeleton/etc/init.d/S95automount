#!/bin/sh
#
# Automount user shares...
#

definition_file="/etc/fstab"
mount_file="/proc/mounts"

### expects two variables
###	option_string 
###	option_name
### returns option_string
append_option() {
	eval "echo ${1},${2}=\${$2}"
}

### expects one variable
###	device string
### returns device string, or device name if input parameter contains UUID
map_uuid() {
	if [ "${1%=*}" = "UUID" ]; then
		uuid=${1#*=}
		blkid | awk '/'$uuid'/ { gsub(/:/, "", $1); print $1 }'
	else
		eval "echo $1"
	fi
}

### expects two variables
###	option_string 
###	filesystem_type
### returns option_string
parse_options() {
	options_in=$1
	type=$2
	options_out=""
	username="mpd"
	password=""
	mode="ro"
	vers="3.1.1"
	gid=$(grep audio /etc/group | awk 'BEGIN {FS=":"} {print $3}')
	uid=$(grep mpd /etc/passwd | awk 'BEGIN {FS=":"} {print $3}')
	dmask="0022"
	fmask="0022"
	for opt in ${options_in//,/ }
	do
		case $opt in
		gid=*)
			gid=${opt##*=}
			;;
		uid=*)
			uid=${opt##*=}
			;;
		username=*)
			username=${opt##*=}
			;;
		password=*)
			password=${opt##*=}
			;;
		vers=*)
			vers=${opt##*=}
			;;
		r[ow])
			mode=$opt
			;;
		user|users)
			# discard option
			;;
		*)
			options_out="$options_out,$opt"
			;;
		esac
	done
	# default mode is ro, unless specified
	options_out="$options_out,$mode"
	# these options should only be relevant for CIFS shares
	if [ $type = "cifs" ]; then
		# add group and user id
		options_out=`append_option ${options_out} gid`
		options_out=`append_option ${options_out} uid`
		# user name and password were supplied
		if [ -n "$username" -a -n "$password" ]; then
			options_out=`append_option ${options_out} username`
			options_out=`append_option ${options_out} password`
		# otherwise just append user name
		elif [ -n "$username" ]; then
			options_out=`append_option ${options_out} username`
		fi
		# add smb version
		options_out=`append_option ${options_out} vers`
	elif [ $type = "vfat" ] || [ $type = "ntfs" ] ; then
		# set owner and group
		options_out=`append_option ${options_out} gid`
		options_out=`append_option ${options_out} uid`
		# set dmask and fmask
		options_out=`append_option ${options_out} dmask`
		options_out=`append_option ${options_out} fmask`
	fi
	# first character will be an extra ','
	if [ -n "$options_out" ]; then options_out=${options_out:1}; fi
	echo ${options_out}
	return 0
}

if [ "$1" = "start" -o "$1" = "sync" ]; then
	echo "Automount user shares..."
	while read file_system mount_point type options dump pass; do
		# filter entries that are comments
		if [ ${file_system###*} ]; then 
			# filter entries that are incomplete
			if [ ${file_system} -a ${mount_point} -a ${type} ]; then 
				# check if file system is already mounted
				mounted=`grep "$(map_uuid $file_system) $mount_point $type" $mount_file`
				if [ -z "${mounted}" ]; then
					# ignore entries with "noauto" set
					if [ ! ${options##*noauto*} ]; then continue; fi
					# create mount point
					mkdir -p $mount_point || continue
					# add some options for cifs file systems
					options=`parse_options ${options} $type` || continue
					# mount this file system
					mount -t $type -o $options $file_system $mount_point || continue
					echo "mounted $file_system on $mount_point"
				fi
			fi
		fi
	done < ${definition_file}
	echo "Done"

elif [ "$1" = "stop" ]; then
	echo "Unmount network shares..."
	cat $mount_file > /tmp/mounts
	while read file_system mount_point type options dump pass; do
	if [ "$type" = "cifs" -o "$type" = "nfs" ]; then
		umount $mount_point
	fi
	done < /tmp/mounts
	echo "Done"

else
        echo "Usage: $0 {start | stop | sync}"
fi
