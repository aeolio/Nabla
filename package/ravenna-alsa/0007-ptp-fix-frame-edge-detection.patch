Logging should not occur inside a critical section. 

Adapt timestamping to only use rounding. This significantly reduces errors later in the "Report drop" section of this function. 

--- a/driver/PTP.c
+++ b/driver/PTP.c
@@ -260,13 +260,12 @@
 void ResetPTPLock(TClock_PTP* self, bool bUseMutex)
 {
     unsigned long flags;
+    MTAL_DP("ResetPTPLock()\n");
 	if(bUseMutex)
 		spin_lock_irqsave((spinlock_t*)self->m_csPTPTime, flags);
 
 	{
-		MTAL_DP("ResetPTPLock()\n");
 		self->m_usPTPLockCounter = PTP_LOCK_HYSTERESIS;
-
 		self->m_dTIC_IGR = 0;
 		self->m_usTICLockCounter = TIC_LOCK_HYSTERESIS;
 	}
@@ -945,12 +950,18 @@
             //MTAL_DP("2.ui64Q = %I64u \n", ui64Q);
 
             //MTAL_DP("Q : %I64u R: %u ", ui64Q, ui32R);
-            if(ui32R < 4 * self->m_ui32SamplingRate / 44100) // to avoid using timestamps outside 80us of theoretical time
+#if 0
+			// edge detection window, initially 80 us, rounded
+			uint32_t ui32Window = (uint32_t) ((((uint64_t) self->m_ui32FrameSize) +self->m_dTIC_BasePeriod /2) *80000ULL /self->m_dTIC_BasePeriod);
+			if( ui32Window > self->m_ui32FrameSize / 2 )
+				ui32Window = self->m_ui32FrameSize / 2;
+			ui32Window = max(self->m_ui32FrameSize /100, 1);
+            if(ui32R < ui32Window) // to avoid using timestamps outside 80us of theoretical time
             {
                 ui64CurrentTICCount = ui64Q + 1; // we add 1 because ui64Q is the count for the previous frame
                 //iTICCountUpdateMethod = 1;
             }
-            else if(ui32R > self->m_ui32FrameSize - 4 * self->m_ui32SamplingRate / 44100)
+            else if(ui32R > self->m_ui32FrameSize - ui32Window)
             {
                 ui64CurrentTICCount = ui64Q + 1 + 1; // we add 1 because ui64Q is the count for the previous frame
                 //iTICCountUpdateMethod = 2;
@@ -965,6 +976,18 @@
 				ui64CurrentTICCount = self->m_ui64LastTIC_Count + 1;
                 //iTICCountUpdateMethod = 3;
             }
+#else
+            // round the timestamp
+            if(ui32R < self->m_ui32FrameSize /2)
+                ui64CurrentTICCount = ui64Q;
+            else
+                ui64CurrentTICCount = ui64Q + 1;
+            // slight overshoots may happen due to variations in the timer loop
+            if (ui64CurrentTICCount == self->m_ui64LastTIC_Count)
+                ui64CurrentTICCount += 1;
+            else if (ui64CurrentTICCount == self->m_ui64LastTIC_Count + 2)
+                ui64CurrentTICCount -= 1;
+#endif
         }
 
 		ui64AbsoluteTime = self->m_ui64TIC_NextAbsoluteTime;
