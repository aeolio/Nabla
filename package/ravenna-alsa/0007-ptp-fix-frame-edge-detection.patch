Logging should not occur inside a critical section. 

Next absolute time calculation should not try to adjust by more than one time unit when fractions sum up. 
Adapt timestamping to only use rounding. This significantly reduces errors later in the "Report drop" section of this function. 

--- a/driver/PTP.c
+++ b/driver/PTP.c
@@ -260,13 +260,12 @@
 void ResetPTPLock(TClock_PTP* self, bool bUseMutex)
 {
     unsigned long flags;
+    MTAL_DP("ResetPTPLock()\n");
 	if(bUseMutex)
 		spin_lock_irqsave((spinlock_t*)self->m_csPTPTime, flags);
 
 	{
-		MTAL_DP("ResetPTPLock()\n");
 		self->m_usPTPLockCounter = PTP_LOCK_HYSTERESIS;
-
 		self->m_dTIC_IGR = 0;
 		self->m_usTICLockCounter = TIC_LOCK_HYSTERESIS;
 	}
@@ -844,20 +848,20 @@
     return &self->m_csSAC_Time_Lock;
 }*/
 
-
 ///////////////////////////////////////////////////////////////////////////////
 void computeNextAbsoluteTime(TClock_PTP* self, uint32_t ui32FrameCount)
 {
-	uint64_t ui64Period = self->m_dTIC_CurrentPeriod / PS_2_REF_UNIT; // [ps -> 100us]
-
-	self->m_ui64TIC_NextAbsoluteTime += ui64Period * ui32FrameCount;
-	self->m_dTIC_NextAbsoluteTime_frac += CW_ll_modulo(self->m_dTIC_CurrentPeriod, PS_2_REF_UNIT) * ui32FrameCount;
-	if (self->m_dTIC_NextAbsoluteTime_frac > PS_2_REF_UNIT)
-	{
-		uint32_t ui32EpsilonCount = (uint32_t)(self->m_dTIC_NextAbsoluteTime_frac) / PS_2_REF_UNIT;
-		self->m_dTIC_NextAbsoluteTime_frac -= PS_2_REF_UNIT * ui32EpsilonCount;
-		self->m_ui64TIC_NextAbsoluteTime += ui32EpsilonCount;
-	}
+    uint64_t ui64Period = self->m_dTIC_CurrentPeriod / PS_2_REF_UNIT; // [ps -> 100us]
+    uint64_t ui64Fraction = CW_ll_modulo(self->m_dTIC_CurrentPeriod, PS_2_REF_UNIT); // [ps -> 100us]
+
+    self->m_ui64TIC_NextAbsoluteTime += ui64Period * ui32FrameCount;
+    self->m_dTIC_NextAbsoluteTime_frac += ui64Fraction * ui32FrameCount;
+    if (self->m_dTIC_NextAbsoluteTime_frac > PS_2_REF_UNIT)
+    {
+        // do not correct by more than one time unit in one loop
+        self->m_dTIC_NextAbsoluteTime_frac -= PS_2_REF_UNIT;
+        self->m_ui64TIC_NextAbsoluteTime += 1;
+    }
 
 	/* Orignial code with a loop :
 	uint64_t ui64Period = self->m_dTIC_CurrentPeriod / PS_2_REF_UNIT; // [ps -> 100us]
@@ -945,26 +950,17 @@
             //MTAL_DP("2.ui64Q = %I64u \n", ui64Q);
 
             //MTAL_DP("Q : %I64u R: %u ", ui64Q, ui32R);
-            if(ui32R < 4 * self->m_ui32SamplingRate / 44100) // to avoid using timestamps outside 80us of theoretical time
-            {
-                ui64CurrentTICCount = ui64Q + 1; // we add 1 because ui64Q is the count for the previous frame
-                //iTICCountUpdateMethod = 1;
-            }
-            else if(ui32R > self->m_ui32FrameSize - 4 * self->m_ui32SamplingRate / 44100)
-            {
-                ui64CurrentTICCount = ui64Q + 1 + 1; // we add 1 because ui64Q is the count for the previous frame
-                //iTICCountUpdateMethod = 2;
-            }
+
+            // just arithmetically round the timestamp
+            if(ui32R < self->m_ui32FrameSize /2)
+                ui64CurrentTICCount = ui64Q;
             else
-            {
-                // For debug
-                /*if (self->m_ui64LastTIC_Count != ui64Q)
-                {
-                    MTAL_DP("self->m_ui64LastTIC_Count(%llu) != ui64Q(%llu) | ui32R[%llu]\n", self->m_ui64LastTIC_Count, ui64Q, ui32R);
-                }*/
-				ui64CurrentTICCount = self->m_ui64LastTIC_Count + 1;
-                //iTICCountUpdateMethod = 3;
-            }
+                ui64CurrentTICCount = ui64Q + 1;
+            // slight overshoots may happen due to variations in the timer loop
+            if (ui64CurrentTICCount == self->m_ui64LastTIC_Count)
+                ui64CurrentTICCount += 1;
+            else if (ui64CurrentTICCount == self->m_ui64LastTIC_Count + 2)
+                ui64CurrentTICCount -= 1;
         }
 
 		ui64AbsoluteTime = self->m_ui64TIC_NextAbsoluteTime;
