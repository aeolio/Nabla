Kernel log output in file PTP.c 

  function ProcessT1()		fix typo in message format string
  function timerProcess		this section is marked as debug, so change log level to DEBUG

Calculation of TICCount in PTP.c

  function timerProcess		m_i64TIC_PTPToRTXClockOffset is a ps value, scale it with PS_2_REF_UNIT

Kernel log output in file module_timer.c

Since other modules use 100us as a time base, change the values in this location also. 
Log level is adapted to reflect occurrence frequency and severity of the event. 
Logging is done using the MTAL_DP* macros, this allows filtering the output in the future. 
The immediate restart of the timer loop will be initiated not only for events that have already expired, but also if the next event is only a few microseconds away. 
The return value of hrtimer_forward_now() measures number of overruns in terms of the supplied period, so calculate the overrun in terms of the base period and warn only if the next period is skipped completely. 

Additional version dependencies for kernels < 3.10 have been introduced to enable compilation down to version 3.2. 

--- a/driver/PTP.c
+++ b/driver/PTP.c
@@ -621,7 +626,7 @@
 
 					self->m_dTIC_CurrentPeriod = (self->m_dTIC_BasePeriod * self->m_ui64DeltaT2) / ui64DeltaT1; // [ps]
 					//MTAL_DP("self->m_ui64DeltaT2 = %I64u, ui64DeltaT1 = %I64u\n", self->m_ui64DeltaT2 , ui64DeltaT1);
-					MTAL_DP("self->m_dTIC_CurrentPeriod = %ull , self->m_dTIC_BasePeriod = %ull\n", self->m_dTIC_CurrentPeriod , self->m_dTIC_BasePeriod);
+					MTAL_DP("self->m_dTIC_CurrentPeriod = %llu , self->m_dTIC_BasePeriod = %llu\n", self->m_dTIC_CurrentPeriod , self->m_dTIC_BasePeriod);
 
 					self->m_ui64TIC_NextAbsoluteTime = self->m_ui64TIC_LastRTXClockTimeAtT2 + i32DeltaTICFrame + (5 * self->m_dTIC_CurrentPeriod / PS_2_REF_UNIT);
 					self->m_dTIC_NextAbsoluteTime_frac = 0;
@@ -903,7 +908,7 @@
 	/////// debug
 	if (abs((int)((signed)self->m_ui64TIC_NextAbsoluteTime - (signed)ui64CurrentRTXClockTime)) > self->m_dTIC_CurrentPeriod / 2 / PS_2_REF_UNIT)
 	{
-		MTAL_DP("Wake up late of 1/2 period. Now(%llu), Asked(%llu), Diff(%i) [100us] neg means earlier\n", ui64CurrentRTXClockTime, self->m_ui64TIC_NextAbsoluteTime, (int)((signed)ui64CurrentRTXClockTime - (signed)self->m_ui64TIC_NextAbsoluteTime));
+		MTAL_DP_DEBUG("Wake up late of 1/2 period. Now(%llu), Asked(%llu), Diff(%i) [100us] neg means earlier\n", ui64CurrentRTXClockTime, self->m_ui64TIC_NextAbsoluteTime, (int)((signed)ui64CurrentRTXClockTime - (signed)self->m_ui64TIC_NextAbsoluteTime));
 	}
 
 	// Atomicity
@@ -926,8 +931,9 @@
         computeNextAbsoluteTime(self, 1);
         {
             //MTAL_DP("self->m_ui64TIC_NextAbsoluteTime %llu\n", self->m_ui64TIC_NextAbsoluteTime);
-            uint64_t ui64Q = (uint64_t)((ui64CurrentRTXClockTime - self->m_i64TIC_PTPToRTXClockOffset) * (self->m_ui32SamplingRate / 100) / 100) / self->m_ui32FrameSize; // [frame count]
-            uint32_t ui32R = CW_ll_modulo((uint64_t)((ui64CurrentRTXClockTime - self->m_i64TIC_PTPToRTXClockOffset) * (self->m_ui32SamplingRate / 100) / 100), self->m_ui32FrameSize);
+            uint64_t ui64NextFrameTime = ui64CurrentRTXClockTime - self->m_i64TIC_PTPToRTXClockOffset / PS_2_REF_UNIT + self->m_dTIC_CurrentPeriod / PS_2_REF_UNIT;
+            uint64_t ui64Q = (uint64_t)(ui64NextFrameTime * (self->m_ui32SamplingRate / 100) / 100) / self->m_ui32FrameSize; // [frame count]
+            uint32_t ui32R = CW_ll_modulo((uint64_t)(ui64NextFrameTime * (self->m_ui32SamplingRate / 100) / 100), self->m_ui32FrameSize);
             //uint32_t ui32R = (uint64_t)(CInt128(ui64CurrentRTXClockTime - self->m_i64TIC_PTPToRTXClockOffset) * CInt128(self->m_ui32SamplingRate / 100) / CInt128(100000)) % self->m_ui32FrameSize;
 
             //if (print_coutner % 1000 == 0)
--- a/driver/module_timer.c
+++ b/driver/module_timer.c
@@ -45,8 +45,10 @@
 static uint64_t base_period_;
 static uint64_t max_period_allowed;
 static uint64_t min_period_allowed;
+static uint64_t timer_resolution;
 static int stop_;
 
+#define NS_TO_100US(x) ((x) / 100000ULL)
 
 enum hrtimer_restart timer_callback(struct hrtimer *timer)
 {
@@ -61,17 +63,17 @@
         get_clock_time(&now);
         period = ktime_set(0, next_wakeup - now);
 
-        if (now > next_wakeup)
+        if (now > next_wakeup || next_wakeup - now < timer_resolution)
         {
-            printk(KERN_INFO "Timer won't sleep, clock_timer is recall instantly\n");
-            period = ktime_set(0, 0);
+            MTAL_DP_DEBUG("Timer won't sleep, clock_timer is recall instantly\n");
+            period = ktime_set(0, 0); // force loop
         }
         else if (ktime_to_ns(period) > max_period_allowed || ktime_to_ns(period) < min_period_allowed)
         {
-            printk(KERN_INFO "Timer period out of range: %lld [ms]. Target period = %lld\n", ktime_to_ns(period) / 1000000, base_period_ / 1000000);
+            MTAL_DP_DEBUG("Timer period out of range: %lld [100 us]. Target period = %lld [100 us]\n", NS_TO_100US(ktime_to_ns(period)), NS_TO_100US(base_period_));
             if (ktime_to_ns(period) > (unsigned long)5E9L)
             {
-                printk(KERN_ERR "Timer period greater than 5s, set it to 1s!\n");
+                MTAL_DP_DEBUG("Timer period greater than 5s, set it to 1s!\n");
                 period = ktime_set(0,((unsigned long)1E9L)); //1s
             }
         }
@@ -83,13 +85,13 @@
     }
     while (ktime_to_ns(period) == 0); // this able to be rarely true
 
-    ///ret_overrun = hrtimer_forward(timer, kt_now, period);
     ret_overrun = hrtimer_forward_now(timer, period);
-    // comment it when running in VM
-    if(ret_overrun > 1)
-        printk(KERN_INFO "Timer overrun ! (%d times)\n", ret_overrun);
+    // only warn for completely lost periods
+	// the 50% overrun is monitored in timerProcess() 
+    if(unlikely(ret_overrun && ktime_to_ns(period) * ret_overrun > base_period_ * 2))
+        MTAL_DP_INFO("Timer overrun ! (%d frames)\n", (int) (ktime_to_ns(period) * ret_overrun / base_period_));
+
     return HRTIMER_RESTART;
-
 }
 
 int init_clock_timer(void)
@@ -120,8 +122,10 @@
     ktime_t period = ktime_set(0, base_period_); //100 ms
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5,2,0)
     hrtimer_start(&my_hrtimer_, period, HRTIMER_MODE_ABS);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(4,16,0)
+    tasklet_hrtimer_start(&my_hrtimer_, period, HRTIMER_MODE_ABS_SOFT);
 #else
-    tasklet_hrtimer_start(&my_hrtimer_, period, HRTIMER_MODE_ABS_SOFT);
+    tasklet_hrtimer_start(&my_hrtimer_, period, HRTIMER_MODE_ABS);
 #endif
 
     return 0;
@@ -156,10 +160,18 @@
     // *clock_time = monotime.tv_sec * 1000000000L + monotime.tv_nsec;
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,2,0)
+#define hrtimer_resolution LOW_RES_NSEC
+#endif
+
 void set_base_period(uint64_t base_period)
 {
     base_period_ = base_period;
     min_period_allowed = base_period_ / 7;
     max_period_allowed = (base_period_ * 10) / 6;
-    printk(KERN_INFO "Base period set to %lld ns\n", base_period_);
+	/* the granularity of the timer loop */
+	timer_resolution = min(min_period_allowed / 2, 2000ULL);
+	if( timer_resolution < hrtimer_resolution )
+		timer_resolution = hrtimer_resolution;
+    MTAL_DP_INFO("Base period set to %lld ns\n", base_period_);
 }
