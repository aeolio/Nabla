diff -Naur tools/tracing/rtla/src/osnoise_hist.c /home/iago/rpi64/build/linux-6.1.15/tools/tracing/rtla/src/osnoise_hist.c
--- a/tools/tracing/rtla/src/osnoise_hist.c	2023-03-07 09:14:07.769838499 +0100
+++ b/tools/tracing/rtla/src/osnoise_hist.c	2023-03-07 08:02:55.314455000 +0100
@@ -45,6 +45,7 @@
 
 	unsigned long long	min_sample;
 	unsigned long long	sum_sample;
+	unsigned long long	var_sample;
 	unsigned long long	max_sample;
 
 };
@@ -121,7 +122,7 @@
 {
 	struct osnoise_hist_params *params = tool->params;
 	struct osnoise_hist_data *data = tool->data;
-	unsigned long long total_duration;
+	unsigned long long total_duration, variance;
 	int entries = data->entries;
 	int bucket;
 	int *hist;
@@ -133,11 +134,13 @@
 		bucket = duration / data->bucket_size;
 
 	total_duration = duration * count;
+	variance = total_duration * duration;
 
 	hist = data->hist[cpu].samples;
 	data->hist[cpu].count += count;
 	update_min(&data->hist[cpu].min_sample, &duration);
 	update_sum(&data->hist[cpu].sum_sample, &total_duration);
+	update_sum(&data->hist[cpu].var_sample, &variance);
 	update_max(&data->hist[cpu].max_sample, &duration);
 
 	if (bucket < entries)
@@ -356,6 +359,31 @@
 
 	}
 	trace_seq_printf(trace->seq, "\n");
+
+	/* standard deviation */
+	if (!params->no_index)
+		trace_seq_printf(trace->seq, "sd:   ");
+
+	for (cpu = 0; cpu < data->nr_cpus; cpu++) {
+		if (params->cpus && !params->monitored_cpus[cpu])
+			continue;
+
+		if (!data->hist[cpu].count)
+			continue;
+
+		double var = ((double) data->hist[cpu].var_sample) /
+			(data->hist[cpu].count-1);
+		double avg = ((double) data->hist[cpu].sum_sample) * 
+			data->hist[cpu].sum_sample /
+			(data->hist[cpu].count-1) /
+			data->hist[cpu].count;
+
+		if (data->hist[cpu].count)
+			trace_seq_printf(trace->seq, "%9.2f ", sqrth(var - avg));
+		else
+			trace_seq_printf(trace->seq, "        - ");
+	}
+	trace_seq_printf(trace->seq, "\n");
 	trace_seq_do_printf(trace->seq);
 	trace_seq_reset(trace->seq);
 }
diff -Naur tools/tracing/rtla/src/timerlat_hist.c /home/iago/rpi64/build/linux-6.1.15/tools/tracing/rtla/src/timerlat_hist.c
--- a/tools/tracing/rtla/src/timerlat_hist.c	2023-03-07 09:14:49.023996902 +0100
+++ b/tools/tracing/rtla/src/timerlat_hist.c	2023-03-07 08:03:29.041735000 +0100
@@ -51,10 +51,12 @@
 
 	unsigned long long	min_irq;
 	unsigned long long	sum_irq;
+	unsigned long long	var_irq;
 	unsigned long long	max_irq;
 
 	unsigned long long	min_thread;
 	unsigned long long	sum_thread;
+	unsigned long long	var_thread;
 	unsigned long long	max_thread;
 };
 
@@ -144,6 +146,7 @@
 {
 	struct timerlat_hist_params *params = tool->params;
 	struct timerlat_hist_data *data = tool->data;
+	unsigned long long variance;
 	int entries = data->entries;
 	int bucket;
 	int *hist;
@@ -154,17 +157,21 @@
 	if (data->bucket_size)
 		bucket = latency / data->bucket_size;
 
+	variance = latency * latency;
+
 	if (!thread) {
 		hist = data->hist[cpu].irq;
 		data->hist[cpu].irq_count++;
 		update_min(&data->hist[cpu].min_irq, &latency);
 		update_sum(&data->hist[cpu].sum_irq, &latency);
+		update_sum(&data->hist[cpu].var_irq, &variance);
 		update_max(&data->hist[cpu].max_irq, &latency);
 	} else {
 		hist = data->hist[cpu].thread;
 		data->hist[cpu].thread_count++;
 		update_min(&data->hist[cpu].min_thread, &latency);
 		update_sum(&data->hist[cpu].sum_thread, &latency);
+		update_sum(&data->hist[cpu].var_thread, &variance);
 		update_max(&data->hist[cpu].max_thread, &latency);
 	}
 
@@ -341,6 +348,46 @@
 					data->hist[cpu].max_thread);
 	}
 	trace_seq_printf(trace->seq, "\n");
+
+	/* standard deviation */
+	if (!params->no_index)
+		trace_seq_printf(trace->seq, "sd:   ");
+
+	for (cpu = 0; cpu < data->nr_cpus; cpu++) {
+		if (params->cpus && !params->monitored_cpus[cpu])
+			continue;
+
+		if (!data->hist[cpu].irq_count && !data->hist[cpu].thread_count)
+			continue;
+
+		if (!params->no_irq) {
+			if (data->hist[cpu].irq_count) {
+				double var = ((double) data->hist[cpu].var_irq) / 
+					(data->hist[cpu].irq_count-1);
+				double avg = ((double) data->hist[cpu].sum_irq) * 
+					data->hist[cpu].sum_irq / 
+					((data->hist[cpu].irq_count-1) * data->hist[cpu].irq_count);
+				trace_seq_printf(trace->seq, "%9.2f ", sqrth(var - avg));
+			}
+			else
+				trace_seq_printf(trace->seq, "        - ");
+		}
+
+		if (!params->no_thread) {
+			if (data->hist[cpu].thread_count) {
+				double var = ((double) data->hist[cpu].var_thread) /
+					(data->hist[cpu].thread_count-1);
+				double avg = ((double) data->hist[cpu].sum_thread) *
+					data->hist[cpu].sum_thread /
+					(data->hist[cpu].thread_count-1) /
+					data->hist[cpu].thread_count;
+				trace_seq_printf(trace->seq, "%9.2f ", sqrth(var - avg));
+			}
+			else
+				trace_seq_printf(trace->seq, "        - ");
+		}
+	}
+	trace_seq_printf(trace->seq, "\n");
 	trace_seq_do_printf(trace->seq);
 	trace_seq_reset(trace->seq);
 }
diff -Naur tools/tracing/rtla/src/utils.c /home/iago/rpi64/build/linux-6.1.15/tools/tracing/rtla/src/utils.c
--- a/tools/tracing/rtla/src/utils.c	2023-03-03 11:52:25.000000000 +0100
+++ b/tools/tracing/rtla/src/utils.c	2023-03-07 08:54:21.051112944 +0100
@@ -529,3 +529,40 @@
 
 	return fd;
 }
+
+/*
+ * sqrth - calculate an estimate of the square root af a value
+ *
+ * This is used to calculate a rough estimate of the standard deviation
+ * from the variance. The objective is to not include the stdlib math 
+ * in a kernel build. The algorithm used is Heron's method. 
+ *
+ * Return: the square root of value with two-digit precision
+ */
+double sqrth(double value)
+{
+	int iterations = 10;
+	double precision = 0.01;
+	double d, last_estimate, next_estimate;
+
+	/* initial estimate */
+	if (value >= 1)
+		last_estimate = (1 + value) / 2;
+	else
+		last_estimate = (1 - value) / 2;
+
+	while (iterations--)
+	{
+		next_estimate = (value/last_estimate + last_estimate) / 2;
+
+		d = next_estimate - last_estimate;
+		if (d < 0)
+			d = (-d);
+		if (d < precision)
+			break;
+
+		last_estimate = next_estimate;
+	}
+
+	return (next_estimate);
+}
diff -Naur tools/tracing/rtla/src/utils.h /home/iago/rpi64/build/linux-6.1.15/tools/tracing/rtla/src/utils.h
--- a/tools/tracing/rtla/src/utils.h	2023-03-03 11:52:25.000000000 +0100
+++ b/tools/tracing/rtla/src/utils.h	2023-03-07 08:02:22.851169000 +0100
@@ -56,3 +56,4 @@
 int parse_prio(char *arg, struct sched_attr *sched_param);
 int set_comm_sched_attr(const char *comm_prefix, struct sched_attr *attr);
 int set_cpu_dma_latency(int32_t latency);
+double sqrth(double value);
