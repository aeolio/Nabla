--- a/driver/audio_driver.c
+++ b/driver/audio_driver.c
@@ -43,7 +43,6 @@
 #include <sound/control.h>
 #include <sound/tlv.h>
 #include <sound/pcm.h>
-#include <sound/pcm-indirect.h> // for mmap
 #include <sound/pcm_params.h>
 #include <sound/initval.h>
 
@@ -77,11 +76,6 @@
 static char *id = SNDRV_DEFAULT_STR1; /* Id for card */
 static bool enable = SNDRV_DEFAULT_ENABLE1; /* Enable this card */
 static int pcm_devs = 1;
-//static int pcm_substreams = 8; // todo
-//#define MUTE_CHECK
-#ifdef MUTE_CHECK
-static bool playback_mute_detected = false;
-#endif
 
 module_param(index, int, 0444);
 MODULE_PARM_DESC(index, "Index value for " CARD_NAME " soundcard.");
@@ -112,7 +106,8 @@
 static int mr_alsa_audio_pcm_capture_copy_internal( struct snd_pcm_substream *substream,
                                             int channel, uint32_t pos,
                                             void __user *src,
-                                            snd_pcm_uframes_t count, bool to_user_space);
+                                            snd_pcm_uframes_t count,
+                                            bool to_user_space);
 static int mr_alsa_audio_pcm_playback_copy( struct snd_pcm_substream *substream,
                                             int channel, snd_pcm_uframes_t pos,
                                             void __user *src,
@@ -120,10 +115,8 @@
 static int mr_alsa_audio_pcm_playback_copy_internal( struct snd_pcm_substream *substream,
                                             int channel, uint32_t pos,
                                             void __user *src,
-                                            snd_pcm_uframes_t count);
-static int mr_alsa_audio_pcm_playback_silence(  struct snd_pcm_substream *substream,
-                                            int channel, snd_pcm_uframes_t pos,
-                                            snd_pcm_uframes_t count);
+                                            snd_pcm_uframes_t count,
+                                            bool from_user_space);
 
 /// "chip" : the main private structure
 struct mr_alsa_audio_chip
@@ -177,10 +170,14 @@
     struct snd_card *card;  /* one card */
     struct snd_pcm *pcm;    /* has one pcm */
     
-    struct snd_pcm_indirect pcm_playback_indirect;
-    atomic_t dma_playback_offset; // to be used with atomic_read, atomic_set
-    struct snd_pcm_indirect pcm_capture_indirect;
-    atomic_t dma_capture_offset; // to be used with atomic_read, atomic_set 
+    uint32_t dma_playback_offset;
+    uint32_t dma_capture_offset;
+
+    unsigned int pcm_playback_buffer_size;
+    unsigned int pcm_capture_buffer_size;
+
+    uint8_t *dma_playback_buffer;
+    uint8_t *dma_capture_buffer;
 };
 
 
@@ -507,13 +504,28 @@
 }
 static uint32_t mr_alsa_audio_get_playback_buffer_size_in_frames(void *rawchip)
 {
-    if(rawchip)
-    {
-        struct mr_alsa_audio_chip *chip = (struct mr_alsa_audio_chip*)rawchip;
-        if(chip->playback_buffer)
-            return MR_ALSA_RINGBUFFER_NB_FRAMES;
-    }
-    return 0;
+    uint32_t res = 0;
+    if (rawchip)
+    {
+        struct mr_alsa_audio_chip* chip = (struct mr_alsa_audio_chip*)rawchip;
+        //spin_lock_irq(&chip->lock);
+        {
+            struct snd_pcm_runtime* runtime = chip->playback_substream ? chip->playback_substream->runtime : NULL;
+            if (chip->playback_buffer)
+            {
+                if (runtime && runtime->period_size != 0 && runtime->periods != 0)
+                {
+                    res = chip->current_dsd ? MR_ALSA_RINGBUFFER_NB_FRAMES : runtime->period_size * runtime->periods;
+                }
+                else
+                {
+                    res = MR_ALSA_RINGBUFFER_NB_FRAMES;
+                }
+            }
+        }
+        //spin_unlock_irq(&chip->lock);
+    }
+    return res;
 
 }
 static void* mr_alsa_audio_get_capture_buffer(void *rawchip)
@@ -594,7 +606,8 @@
         uint32_t ring_buffer_size = MR_ALSA_RINGBUFFER_NB_FRAMES; // init to the max size possible
         uint32_t ptp_frame_size;
         struct mr_alsa_audio_chip *chip = (struct mr_alsa_audio_chip*)rawchip;
-        spin_lock_irq(&chip->lock);
+
+        spin_lock(&chip->lock);
         chip->mr_alsa_audio_ops->get_interrupts_frame_size(chip->ravenna_peer, &ptp_frame_size);
         if(direction == 1 && chip->capture_substream != NULL)
         {
@@ -611,24 +624,22 @@
                 runtime->access == SNDRV_PCM_ACCESS_MMAP_NONINTERLEAVED || 
                 runtime->access == SNDRV_PCM_ACCESS_MMAP_COMPLEX)
             {
-                unsigned long bytes_to_frame_factor = runtime->channels * snd_pcm_format_physical_width(runtime->format) >> 3;
-                unsigned int pcm_buffer_size = snd_pcm_lib_buffer_bytes(chip->capture_substream);
-                unsigned int pos;
-                uint32_t offset = 0;
-                // char jitter_buffer_byte_len = 3;
-                // chip->mr_alsa_audio_ops->get_jitter_buffer_sample_bytelength(chip->ravenna_peer, &jitter_buffer_byte_len);
-                
-                pos = atomic_read(&chip->dma_capture_offset);
-                pos += ptp_frame_size * bytes_to_frame_factor;
-                if (pos >= pcm_buffer_size)
+                unsigned long bytes_to_frame_factor = runtime->channels * chip->current_alsa_capture_stride;
+
+                //printk(KERN_DEBUG "capture copy pos=%u, dma_pos=%u, count=%u, channels=%d pcm_size=%u\n", chip->capture_buffer_pos, pos, ptp_frame_size, runtime->channels, pcm_buffer_size);
+                mr_alsa_audio_pcm_capture_copy_internal(chip->capture_substream, runtime->channels/*channel*/,
+                    chip->capture_buffer_pos, chip->dma_capture_buffer + chip->dma_capture_offset/**src*/, ptp_frame_size, false);
+
+                chip->dma_capture_offset += ptp_frame_size * bytes_to_frame_factor;
+                if (chip->dma_capture_offset >= chip->pcm_capture_buffer_size)
                 {
-                    pos -= pcm_buffer_size;
+                    chip->dma_capture_offset -= chip->pcm_capture_buffer_size;
                 }
-                atomic_set(&chip->dma_capture_offset, pos);
-                
-                chip->mr_alsa_audio_ops->get_input_jitter_buffer_offset(chip->ravenna_peer, &offset);
-                //printk(KERN_DEBUG "Interrupt Capture pos = %u \n", offset);
             }
+
+            chip->capture_buffer_pos += ptp_frame_size;
+            if(chip->capture_buffer_pos >= ring_buffer_size)
+                chip->capture_buffer_pos -= ring_buffer_size;
             
             /// Ravenna DSD always uses a rate of 352k with eventual zero padding to maintain a 32 bit alignment
             /// while DSD in ALSA uses a continuous 8, 16 or 32 bit aligned stream with at 352k, 176k or 88k
@@ -636,7 +647,9 @@
             if(++chip->current_capture_interrupt_idx >= chip->nb_capture_interrupts_per_period)
             {
                 chip->current_capture_interrupt_idx = 0;
+                spin_unlock(&chip->lock);
                 snd_pcm_period_elapsed(chip->capture_substream);
+                spin_lock(&chip->lock);
             }
         }
         else if(direction == 0 && chip->playback_substream != NULL)
@@ -648,27 +661,27 @@
                 printk(KERN_ERR "mr_alsa_audio_pcm_interrupt playback period_size*periods > MR_ALSA_RINGBUFFER_NB_FRAMES\n");
                 return -2;
             }
-            
+
             /// DMA case
             if (runtime->access == SNDRV_PCM_ACCESS_MMAP_INTERLEAVED || 
                 runtime->access == SNDRV_PCM_ACCESS_MMAP_NONINTERLEAVED || 
                 runtime->access == SNDRV_PCM_ACCESS_MMAP_COMPLEX)
             {
-                unsigned long bytes_to_frame_factor = runtime->channels * snd_pcm_format_physical_width(runtime->format) >> 3;
-                unsigned int pcm_buffer_size = snd_pcm_lib_buffer_bytes(chip->playback_substream);
-                unsigned int pos;
-                
-                pos = atomic_read(&chip->dma_playback_offset);
-                pos += ptp_frame_size * bytes_to_frame_factor;
-                if (pos >= pcm_buffer_size)
+                unsigned long bytes_to_frame_factor = runtime->channels * chip->current_alsa_playback_stride;
+
+                //printk(KERN_DEBUG "playback copy pos=%u, dma_pos=%u, count=%u, channels=%d pcm_size=%u\n", chip->playback_buffer_pos, pos, ptp_frame_size, runtime->channels, pcm_buffer_size);
+                mr_alsa_audio_pcm_playback_copy_internal(chip->playback_substream, runtime->channels/*channel*/,
+                    chip->playback_buffer_pos/*pos*/, chip->dma_playback_buffer + chip->dma_playback_offset/*src*/, ptp_frame_size/*count*/, false);
+
+                chip->dma_playback_offset += ptp_frame_size * bytes_to_frame_factor;
+                if (chip->dma_playback_offset >= chip->pcm_playback_buffer_size)
                 {
-                    pos -= pcm_buffer_size;
+                    chip->dma_playback_offset -= chip->pcm_playback_buffer_size;
                 }
-                atomic_set(&chip->dma_playback_offset, pos);
             }
-            
+
             chip->playback_buffer_pos += ptp_frame_size;
-            if(chip->playback_buffer_pos >= ring_buffer_size)
+            if (chip->playback_buffer_pos >= ring_buffer_size)
                 chip->playback_buffer_pos -= ring_buffer_size;
 
             /// Ravenna DSD always uses a rate of 352k with eventual zero padding to maintain a 32 bit alignment
@@ -678,10 +691,12 @@
             {
                 chip->playback_buffer_rav_sac += ptp_frame_size;
                 chip->current_playback_interrupt_idx = 0;
+                spin_unlock(&chip->lock);
                 snd_pcm_period_elapsed(chip->playback_substream);
+                spin_lock(&chip->lock);
             }
         }
-        spin_unlock_irq(&chip->lock);
+        spin_unlock(&chip->lock);
         return 0;
     }
     return -1;
@@ -918,17 +933,14 @@
             /// Fill the additional delay between the packet output and the sound eared
             chip->mr_alsa_audio_ops->get_playout_delay(chip->ravenna_peer, &runtime->delay);
 
-            // TODO: snd_pcm_format_set_silence(SNDRV_PCM_FORMAT_S24_3LE, chip->mr_alsa_audio_ops->, )
-
-            atomic_set(&chip->dma_playback_offset, 0);
-            memset(&chip->pcm_playback_indirect, 0, sizeof(chip->pcm_playback_indirect));
-            chip->pcm_playback_indirect.hw_buffer_size = chip->pcm_playback_indirect.sw_buffer_size = snd_pcm_lib_buffer_bytes(substream);
+            chip->dma_playback_offset = 0;
+            chip->dma_playback_buffer = runtime->dma_area;
+            chip->pcm_playback_buffer_size = snd_pcm_lib_buffer_bytes(chip->playback_substream);
         }
         else if(substream->stream == SNDRV_PCM_STREAM_CAPTURE)
         {
             uint32_t offset = 0;
             chip->mr_alsa_audio_ops->get_input_jitter_buffer_offset(chip->ravenna_peer, &offset);
-            
             
             printk(KERN_DEBUG "mr_alsa_audio_pcm_prepare for capture stream\n");
             if(chip->ravenna_peer)
@@ -947,12 +959,10 @@
             chip->capture_buffer_pos = offset;
             chip->current_capture_interrupt_idx = 0;
             chip->nb_capture_interrupts_per_period = ((runtime_dsd_mode != 0)? (MR_ALSA_PTP_FRAME_RATE_FOR_DSD / runtime->rate) : 1);
-            // TODO: snd_pcm_format_set_silence
             
-            atomic_set(&chip->dma_capture_offset, 0);
-            memset(&chip->pcm_capture_indirect, 0, sizeof(chip->pcm_capture_indirect));
-            chip->pcm_capture_indirect.hw_buffer_size = snd_pcm_lib_buffer_bytes(substream);
-            chip->pcm_capture_indirect.sw_buffer_size = snd_pcm_lib_buffer_bytes(substream);
+            chip->dma_capture_offset = 0;
+            chip->dma_capture_buffer = runtime->dma_area;
+            chip->pcm_capture_buffer_size = snd_pcm_lib_buffer_bytes(chip->capture_substream);
         }
     }
     else
@@ -974,6 +984,7 @@
     uint32_t offset = 0;
     //printk("entering mr_alsa_audio_pcm_pointer (substream name=%s #%d) ...\n", alsa_sub->name, alsa_sub->number);
 
+    spin_lock(&chip->lock);
     if(alsa_sub->stream == SNDRV_PCM_STREAM_PLAYBACK)
     {
         /// DMA case
@@ -981,7 +992,9 @@
             alsa_sub->runtime->access == SNDRV_PCM_ACCESS_MMAP_NONINTERLEAVED || 
             alsa_sub->runtime->access == SNDRV_PCM_ACCESS_MMAP_COMPLEX)
         {
-            offset = snd_pcm_indirect_playback_pointer(alsa_sub, &chip->pcm_playback_indirect, atomic_read(&chip->dma_playback_offset));
+            struct snd_pcm_runtime *runtime = alsa_sub->runtime;
+            unsigned long bytes_to_frame_factor = runtime->channels * chip->current_alsa_playback_stride;
+            offset = chip->dma_playback_offset / bytes_to_frame_factor;
         }
         else
         {
@@ -1014,7 +1027,9 @@
             alsa_sub->runtime->access == SNDRV_PCM_ACCESS_MMAP_NONINTERLEAVED || 
             alsa_sub->runtime->access == SNDRV_PCM_ACCESS_MMAP_COMPLEX)
         {
-            offset = snd_pcm_indirect_capture_pointer(alsa_sub, &chip->pcm_capture_indirect, atomic_read(&chip->dma_capture_offset));
+            struct snd_pcm_runtime *runtime = alsa_sub->runtime;
+            unsigned long bytes_to_frame_factor = runtime->channels * chip->current_alsa_capture_stride;
+            offset = chip->dma_capture_offset / bytes_to_frame_factor;
         }
         else
         {
@@ -1040,6 +1055,7 @@
         }
         //printk("mr_alsa_audio_pcm_pointer capture offset = %u\n", offset);
     }
+    spin_unlock(&chip->lock);
     return offset;
 }
 
@@ -1156,9 +1172,10 @@
                                             void __user *src,
                                             unsigned long count)
  {
+    struct mr_alsa_audio_chip* chip = snd_pcm_substream_chip(substream);
     struct snd_pcm_runtime *runtime = substream->runtime;
     bool interleaved = (runtime->access == SNDRV_PCM_ACCESS_RW_INTERLEAVED) || (runtime->access == SNDRV_PCM_ACCESS_MMAP_INTERLEAVED) ? 1 : 0;
-    unsigned long bytes_to_frame_factor = runtime->channels * snd_pcm_format_physical_width(runtime->format) >> 3;
+    unsigned long bytes_to_frame_factor = runtime->channels * chip->current_alsa_capture_stride;
     return mr_alsa_audio_pcm_capture_copy(substream, interleaved ? -1 : channel, pos / bytes_to_frame_factor, src, count / bytes_to_frame_factor);
 }
 #endif
@@ -1183,7 +1200,7 @@
     struct snd_pcm_runtime *runtime = substream->runtime;
     int interleaved = (runtime->access == SNDRV_PCM_ACCESS_RW_INTERLEAVED) || (runtime->access == SNDRV_PCM_ACCESS_MMAP_INTERLEAVED) ? 1 : 0;
     unsigned int nb_logical_bits = snd_pcm_format_width(runtime->format);
-    unsigned int strideIn = snd_pcm_format_physical_width(runtime->format) >> 3;
+    unsigned int strideIn = chip->current_alsa_capture_stride;
     uint32_t ravenna_buffer_pos = pos;
 
     // todo DSD capture
@@ -1209,9 +1226,11 @@
 
     if(interleaved)
     {
+        /* removed by Andrea Bondavalli
         int ret_pu;
         char val = 0xf1;
         ret_pu = __put_user(val, (char *)src);
+        */
         switch(nb_logical_bits)
         {
             case 16:
@@ -1246,8 +1265,8 @@
         return -EINVAL;
     }
     return count;
-
-}
+}
+
 /// This callback is called whenever the alsa application wants to write data
 /// We use it here to do all the de-interleaving, format conversion and DSD re-packing
 /// The intermediate buffer is actually the alsa (dma) buffer, allocated in hw_params()
@@ -1258,10 +1277,10 @@
                                             void __user *src,
                                             unsigned long count)
 {
+    struct mr_alsa_audio_chip* chip = snd_pcm_substream_chip(substream);
     struct snd_pcm_runtime *runtime = substream->runtime;
-    bool interleaved = (runtime->access == SNDRV_PCM_ACCESS_RW_INTERLEAVED) || (runtime->access == SNDRV_PCM_ACCESS_MMAP_INTERLEAVED) ? 1 : 0;
-    unsigned long bytes_to_frame_factor = runtime->channels * snd_pcm_format_physical_width(runtime->format) >> 3;
-    return mr_alsa_audio_pcm_playback_copy(substream, interleaved ? -1 : channel, pos / bytes_to_frame_factor, src, count / bytes_to_frame_factor);
+    unsigned long bytes_to_frame_factor = runtime->channels * chip->current_alsa_playback_stride;
+    return mr_alsa_audio_pcm_playback_copy(substream, channel, pos / bytes_to_frame_factor, src, count /bytes_to_frame_factor);
 }
 #endif
 
@@ -1280,28 +1299,25 @@
     /// so respective ring buffers might have different scale and size
     uint32_t ravenna_buffer_pos = pos * chip->nb_playback_interrupts_per_period;
     
-    if(snd_BUG_ON(ravenna_buffer_pos >= MR_ALSA_RINGBUFFER_NB_FRAMES))
-        ravenna_buffer_pos -= MR_ALSA_RINGBUFFER_NB_FRAMES;
-    
-    return mr_alsa_audio_pcm_playback_copy_internal(substream, channel, ravenna_buffer_pos, src, count);
+    return mr_alsa_audio_pcm_playback_copy_internal(substream, channel, ravenna_buffer_pos, src, count, true);
 }
 ///
 static int mr_alsa_audio_pcm_playback_copy_internal( struct snd_pcm_substream *substream,
                                             int channel, uint32_t pos,
                                             void __user *src,
-                                            snd_pcm_uframes_t count)
+                                            snd_pcm_uframes_t count,
+                                            bool from_user_space)
 {
     struct mr_alsa_audio_chip *chip = snd_pcm_substream_chip(substream);
     struct snd_pcm_runtime *runtime = substream->runtime;
     int chn = 0;
-    int interleaved = (runtime->access == SNDRV_PCM_ACCESS_RW_INTERLEAVED) || (runtime->access == SNDRV_PCM_ACCESS_MMAP_INTERLEAVED) ? 1 : 0;
+    int interleaved = (runtime->access == SNDRV_PCM_ACCESS_RW_INTERLEAVED) || (runtime->access == SNDRV_PCM_ACCESS_MMAP_INTERLEAVED) ? 1 : 0;
     unsigned int nb_logical_bits = snd_pcm_format_width(runtime->format);
-    unsigned int strideIn = snd_pcm_format_physical_width(runtime->format) >> 3;
+    unsigned int strideIn = chip->current_alsa_playback_stride;
     unsigned int strideOut = snd_pcm_format_physical_width(SNDRV_PCM_FORMAT_S32_LE) >> 3;
     uint32_t dsdrate = mr_alsa_audio_get_dsd_sample_rate(runtime->format, runtime->rate);
     uint32_t dsdmode = (dsdrate > 0? mr_alsa_audio_get_dsd_mode(dsdrate) : 0);
     uint32_t ravenna_buffer_pos = pos;
-    //uint32_t alsa_ring_buffer_nb_frames = MR_ALSA_RINGBUFFER_NB_FRAMES / chip->nb_playback_interrupts_per_period;
 
     #ifdef MUTE_CHECK
         // mute check
@@ -1311,59 +1327,31 @@
         memset(testblock, 0, sizeof(testblock));
     #endif
     
+	/* Andrea Bondavalli removed this 
     if (channel > 0 && channel >= runtime->channels)
     {
         printk(KERN_WARNING "Channel %d copy ignored because it does not fit the available runtime channels (%d)", channel, runtime->channels);
        return 0;
     }
-
-    //printk(KERN_DEBUG "entering mr_alsa_audio_pcm_playback_copy (substream name=%s #%d) (runtime channels %d) access %d...\n", substream->name, substream->number, runtime->channels, runtime->access));
-
-    /*if(snd_BUG_ON(chip->playback_buffer_rav_sac > chip->playback_buffer_alsa_sac))
-    {
-        printk(KERN_WARNING "mr_alsa_audio_pcm_playback_copy: Playback stall. Missing playback data from the player application.");
-        return -EINVAL;
-    }
-
-    //printk("playback_copy: initial count = %u, alsa_ring_buffer_nb_frames = %u \n", count, alsa_ring_buffer_nb_frames);
-    if(alsa_ring_buffer_nb_frames < chip->playback_buffer_alsa_sac - chip->playback_buffer_rav_sac)
-    {
-        count = 0; /// no room for more playback at the moment
-        printk(KERN_WARNING "playback_copy: no room at the moment (count =%lu) \n", count);
-    }
-
-    if(count > alsa_ring_buffer_nb_frames - (chip->playback_buffer_alsa_sac - chip->playback_buffer_rav_sac))
-    {
-        snd_pcm_uframes_t new_count = (snd_pcm_uframes_t)(alsa_ring_buffer_nb_frames - (chip->playback_buffer_alsa_sac - chip->playback_buffer_rav_sac));
-        printk(KERN_WARNING "playback_copy count overflow 1: change count from %lu to %lu\n", count, new_count);
-        count = new_count;
-    }
-    if(count * chip->nb_playback_interrupts_per_period + ravenna_buffer_pos > MR_ALSA_RINGBUFFER_NB_FRAMES)
-    {
-        snd_pcm_uframes_t new_count = (MR_ALSA_RINGBUFFER_NB_FRAMES - ravenna_buffer_pos) / chip->nb_playback_interrupts_per_period;
-        printk(KERN_WARNING "playback_copy count overflow 2: change count from %lu to %lu\n", count, new_count);
-        count = new_count;
-    }*/
-
-    //printk("playback_copy: rate = %u, dsdmode = %u, #IRQ per period = %u, count = %u, pos = %lu, ravenna_buffer_pos = %u, alsa_pb_sac = %llu, ravenna_pb_sac = %llu\n", (dsdrate > 0? dsdrate : runtime->rate), dsdmode, chip->nb_playback_interrupts_per_period, count, pos, ravenna_buffer_pos, chip->playback_buffer_alsa_sac, chip->playback_buffer_rav_sac);
-    if(count == 0)
-        return 0;
+    */
     
     if(interleaved)
     {
-        {
-            /// de-interleaving
-            unsigned char *in, *out;
-            unsigned int stepIn = runtime->channels * strideIn;
-            unsigned int stepOut = strideOut * chip->nb_playback_interrupts_per_period;
-            size_t ravBuffer_csize = MR_ALSA_RINGBUFFER_NB_FRAMES * strideOut;
-            //printk("playback_copy: de-interleaving %u frames, pos = %llu, ravenna_buffer_pos = %u, with strideIn = %u, strideOut = %u, stepIn = %u, stepOut = %u, ravBuffer_csize = %u \n", count, pos, ravenna_buffer_pos, strideIn, strideOut, stepIn, stepOut, (unsigned int)ravBuffer_csize);
+        /// de-interleaving
+        unsigned char *in, *out;
+        unsigned int stepIn = runtime->channels * strideIn;
+        unsigned int stepOut = strideOut * chip->nb_playback_interrupts_per_period;
+        uint32_t ring_buffer_size = MR_ALSA_RINGBUFFER_NB_FRAMES * strideOut;
+        //printk("playback_copy: de-interleaving %u frames, pos = %llu, ravenna_buffer_pos = %u, with strideIn = %u, strideOut = %u, stepIn = %u, stepOut = %u, ravBuffer_csize = %u \n", count, pos, ravenna_buffer_pos, strideIn, strideOut, stepIn, stepOut, (unsigned int)ravBuffer_csize);
+
+        if (from_user_space)
+        {
             for(chn = 0; chn < runtime->channels; ++chn)
             {
                 uint32_t currentOutPos = ravenna_buffer_pos * strideOut;
                 snd_pcm_uframes_t frmCnt = 0;
                 in = (unsigned char*)src + chn * strideIn;
-                out = chip->playback_buffer + chn * ravBuffer_csize + currentOutPos;
+                out = chip->playback_buffer + chn * ring_buffer_size + currentOutPos;
 
                 ///Conversion to Signed integer 32 bit LE
                 for(frmCnt = 0; frmCnt < count; ++frmCnt)
@@ -1406,34 +1394,30 @@
                     {
                         /// interleaved DSD stream to non interleaved 32 bit aligned blocks with 1/2/4 DSD bytes per 32 bit
                         uint32_t out_cnt;
-                        for(out_cnt = 0; out_cnt < chip->nb_playback_interrupts_per_period; ++out_cnt)
+                        for (out_cnt = 0; out_cnt < chip->nb_playback_interrupts_per_period; ++out_cnt)
                         {
-                            switch(dsdmode)
+                            switch (dsdmode)
                             {
-                                case 1: ///DSD64
-                                    //val = *(int32_t*)(in + out_cnt) & 0xFF;
-                                    __get_user(((unsigned char*)&val)[0], &in[out_cnt]);
-                                    break;
-                                case 2: ///DSD128
-                                    //val = (((int32_t)(in[2 * out_cnt + 1]) << 8) | ((int32_t)(in[2 * out_cnt]))) & 0xFFFF;
-                                    __get_user(((unsigned char*)&val)[1], &in[2 * out_cnt + 1]);
-                                    __get_user(((unsigned char*)&val)[0], &in[2 * out_cnt]);
-                                    break;
-                                case 4: ///DSD256
-                                    //val = *(int32_t*)(in);
-                                    // OR without intermediate copy_from_user buffer
-                                    __get_user(val, (int32_t*)in);
-                                    break;
+                            case 1: ///DSD64
+                                __get_user(((unsigned char*)&val)[0], &in[out_cnt]);
+                                break;
+                            case 2: ///DSD128
+                                __get_user(((unsigned char*)&val)[1], &in[2 * out_cnt + 1]);
+                                __get_user(((unsigned char*)&val)[0], &in[2 * out_cnt]);
+                                break;
+                            case 4: ///DSD256
+                                __get_user(val, (int32_t*)in);
+                                break;
                             }
                             ((int32_t*)out)[out_cnt] = val;
                         }
                     }
 
                     in += stepIn;
-                    if(currentOutPos + stepOut >= ravBuffer_csize)
+                    if (currentOutPos + stepOut >= ring_buffer_size)
                     {
                         currentOutPos = 0;
-                        out = chip->playback_buffer + chn * ravBuffer_csize;
+                        out = chip->playback_buffer + chn * ring_buffer_size;
                     }
                     else
                     {
@@ -1443,56 +1427,37 @@
                 }
             }
         }
-    }
-    else
-    {
-        {
-            //printk("mr_alsa_audio_pcm_playback_copy: no de-interleaving, converting %u frames with strideIn = %u\n", count, strideIn);
-            /// do the format conversion to the Ravenna Ring buffer
+        else
+        {
+            for (chn = 0; chn < runtime->channels; ++chn)
             {
-                unsigned char *in, *out;
-                unsigned int stepIn = strideIn;
-                unsigned int stepOut = strideOut * chip->nb_playback_interrupts_per_period;
-                size_t ravBuffer_csize = MR_ALSA_RINGBUFFER_NB_FRAMES * strideOut;
                 uint32_t currentOutPos = ravenna_buffer_pos * strideOut;
                 snd_pcm_uframes_t frmCnt = 0;
-
-                in = (unsigned char*)src;
-                out = chip->playback_buffer + channel * ravBuffer_csize + currentOutPos;
-                for(frmCnt = 0; frmCnt < count; ++frmCnt)
+                in = (unsigned char*)src + chn * strideIn;
+                out = chip->playback_buffer + chn * ring_buffer_size + currentOutPos;
+                //
+                ///Conversion to Signed integer 32 bit LE
+                for (frmCnt = 0; frmCnt < count; ++frmCnt)
                 {
-                    /// conversion to signed 32 bit integer LE
                     /// assumes Little Endian
-                     int32_t val = 0;
-                    if(dsdmode == 0)
+                    int32_t val = 0;
+                    if (dsdmode == 0)
                     {
-                        switch(nb_logical_bits)
+                        switch (nb_logical_bits)
                         {
-                            case 16:
-                                //val = (((int32_t)(in[1]) << 8) | ((int32_t)(in[0]))) << 16;
-                                // OR
-                                //((unsigned char*)&val)[3] = in[1];
-                                //((unsigned char*)&val)[2] = in[0];
-                                // OR without intermediate copy_from_user buffer
-                                __get_user(((unsigned char*)&val)[3], &in[1]);
-                                __get_user(((unsigned char*)&val)[2], &in[0]);
-                                break;
-                            case 24:
-                                //val = (((int32_t)(in[2]) << 16) | ((int32_t)(in[1]) << 8) | ((int32_t)(in[0]))) << 8;
-                                // OR
-                                // ((unsigned char*)&val)[3] = in[2];
-                                // ((unsigned char*)&val)[2] = in[1];
-                                // ((unsigned char*)&val)[1] = in[0];
-                                // OR without intermediate copy_from_user buffer
-                                __get_user(((unsigned char*)&val)[3], &in[2]);
-                                __get_user(((unsigned char*)&val)[2], &in[1]);
-                                __get_user(((unsigned char*)&val)[1], &in[0]);
-                                break;
-                            case 32:
-                                //val = *(int32_t*)(in);
-                                // OR without intermediate copy_from_user buffer
-                                __get_user(val, (int32_t*)in);
-                                break;
+                        case 16:
+
+                            ((unsigned char*)&val)[3] = in[1];
+                            ((unsigned char*)&val)[2] = in[0];
+                            break;
+                        case 24:
+                            ((unsigned char*)&val)[3] = in[2];
+                            ((unsigned char*)&val)[2] = in[1];
+                            ((unsigned char*)&val)[1] = in[0];
+                            break;
+                        case 32:
+                            val = *(int32_t*)(in);
+                            break;
                         }
                         *((int32_t*)out) = val;
                     }
@@ -1500,33 +1465,29 @@
                     {
                         /// interleaved DSD stream to non interleaved 32 bit aligned blocks with 1/2/4 DSD bytes per 32 bit
                         uint32_t out_cnt;
-                        for(out_cnt = 0; out_cnt < chip->nb_playback_interrupts_per_period; ++out_cnt)
+                        for (out_cnt = 0; out_cnt < chip->nb_playback_interrupts_per_period; ++out_cnt)
                         {
-                            switch(dsdmode)
+                            switch (dsdmode)
                             {
-                                case 1: ///DSD64
-                                    //val = *(int32_t*)(in + out_cnt) & 0xFF;
-                                    __get_user(((unsigned char*)&val)[0], &in[out_cnt]);
-                                    break;
-                                case 2: ///DSD128
-                                    //val = (((int32_t)(in[2 * out_cnt + 1]) << 8) | ((int32_t)(in[2 * out_cnt]))) & 0xFFFF;
-                                    __get_user(((unsigned char*)&val)[1], &in[2 * out_cnt + 1]);
-                                    __get_user(((unsigned char*)&val)[0], &in[2 * out_cnt]);
-                                    break;
-                                case 4: ///DSD256
-                                    //val = *(int32_t*)(in);
-                                    // OR without intermediate copy_from_user buffer
-                                    __get_user(val, (int32_t*)in);
-                                    break;
+                            case 1: ///DSD64
+                                val = *(int32_t*)(in + out_cnt) & 0xFF;
+                                break;
+                            case 2: ///DSD128
+                                val = (((int32_t)(in[2 * out_cnt + 1]) << 8) | ((int32_t)(in[2 * out_cnt]))) & 0xFFFF;
+                                break;
+                            case 4: ///DSD256
+                                val = *(int32_t*)(in);
+                                break;
                             }
                             ((int32_t*)out)[out_cnt] = val;
                         }
                     }
+
                     in += stepIn;
-                    if(currentOutPos + stepOut >= ravBuffer_csize)
+                    if (currentOutPos + stepOut >= ring_buffer_size)
                     {
                         currentOutPos = 0;
-                        out = chip->playback_buffer + channel * ravBuffer_csize;
+                        out = chip->playback_buffer + chn * ring_buffer_size;
                     }
                     else
                     {
@@ -1539,24 +1500,18 @@
     }
     
     
-    #ifdef MUTE_CHECK
-    // First channel check
-    mute_detected = !memcmp(testblock, buffer_to_check, min((ssize_t )256, frames_to_bytes(runtime, count)));
-    if (mute_detected != playback_mute_detected)
-    {
-        if (mute_detected)
-            printk(">>>>Playback buffer mute detected\n");
-        else
-            printk(">>>>Playback buffer signal detected\n");
-        playback_mute_detected = mute_detected;
-    }
-    #endif
+    else // ! interleaved
+    {
+        printk(KERN_WARNING "Uninterleaved Playback is not supported\n");
+        return -EINVAL;
+    }
     
     chip->playback_buffer_alsa_sac += count;
     return count;
 }
 
 
+#if 0/* Andrea Bondivalli removed this section */
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4,13,0)
 static int mr_alsa_audio_pcm_playback_fill_silence(  struct snd_pcm_substream *substream,
                                             int channel, unsigned long pos,
@@ -1779,6 +1734,7 @@
     }
     return 0;
 }
+#endif // removed section
 
 /// hw_params callback
 /// This is called when the hardware parameter (hw_params) is set up by the application, that is, once when
@@ -2344,14 +2300,10 @@
     .pointer =  mr_alsa_audio_pcm_pointer,
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4,13,0)
     .copy_user = mr_alsa_audio_pcm_playback_copy_user,
-    //.copy_kernel = mr_alsa_audio_pcm_playback_copy,
-    .fill_silence = mr_alsa_audio_pcm_playback_fill_silence,
 #else
     .copy =     mr_alsa_audio_pcm_playback_copy,
-    .silence =  mr_alsa_audio_pcm_playback_silence,
 #endif
     .page =     snd_pcm_lib_get_vmalloc_page,
-    .ack =      mr_alsa_audio_pcm_ack,
 };
 
 /////////////////////////////////////////////////////////////////////////////////////
@@ -2366,14 +2318,12 @@
     .pointer =  mr_alsa_audio_pcm_pointer,
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4,13,0)
     .copy_user = mr_alsa_audio_pcm_capture_copy_user,
-    //.copy_kernel = mr_alsa_audio_pcm_capture_copy,
     .fill_silence = NULL,
 #else
     .copy =     mr_alsa_audio_pcm_capture_copy,
     .silence =  NULL, //mr_alsa_audio_pcm_silence,
 #endif
     .page =     snd_pcm_lib_get_vmalloc_page,
-    .ack =      mr_alsa_audio_pcm_ack,
 };
 
 
