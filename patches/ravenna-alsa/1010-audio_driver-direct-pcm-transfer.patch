2021-02-26 Generated patch directly from bondagit repository

--- a/driver/audio_driver.c
+++ b/driver/audio_driver.c
@@ -43,7 +43,6 @@
 #include <sound/control.h>
 #include <sound/tlv.h>
 #include <sound/pcm.h>
-#include <sound/pcm-indirect.h> // for mmap
 #include <sound/pcm_params.h>
 #include <sound/initval.h>
 
@@ -77,11 +76,6 @@
 static char *id = SNDRV_DEFAULT_STR1; /* Id for card */
 static bool enable = SNDRV_DEFAULT_ENABLE1; /* Enable this card */
 static int pcm_devs = 1;
-//static int pcm_substreams = 8; // todo
-//#define MUTE_CHECK
-#ifdef MUTE_CHECK
-static bool playback_mute_detected = false;
-#endif
 
 module_param(index, int, 0444);
 MODULE_PARM_DESC(index, "Index value for " CARD_NAME " soundcard.");
@@ -110,24 +104,13 @@
 static struct alsa_ops *g_mr_alsa_audio_ops;
 
 
-static int mr_alsa_audio_pcm_capture_copy(  struct snd_pcm_substream *substream,
-                                            int channel, snd_pcm_uframes_t pos,
-                                            void __user *src,
-                                            snd_pcm_uframes_t count);
 static int mr_alsa_audio_pcm_capture_copy_internal( struct snd_pcm_substream *substream,
                                             int channel, uint32_t pos,
-                                            void __user *src,
-                                            snd_pcm_uframes_t count, bool to_user_space);
-static int mr_alsa_audio_pcm_playback_copy( struct snd_pcm_substream *substream,
-                                            int channel, snd_pcm_uframes_t pos,
                                             void __user *src,
                                             snd_pcm_uframes_t count);
 static int mr_alsa_audio_pcm_playback_copy_internal( struct snd_pcm_substream *substream,
                                             int channel, uint32_t pos,
                                             void __user *src,
-                                            snd_pcm_uframes_t count);
-static int mr_alsa_audio_pcm_playback_silence(  struct snd_pcm_substream *substream,
-                                            int channel, snd_pcm_uframes_t pos,
                                             snd_pcm_uframes_t count);
 
 /// "chip" : the main private structure
@@ -182,10 +165,14 @@
     struct snd_card *card;  /* one card */
     struct snd_pcm *pcm;    /* has one pcm */
     
-    struct snd_pcm_indirect pcm_playback_indirect;
-    atomic_t dma_playback_offset; // to be used with atomic_read, atomic_set
-    struct snd_pcm_indirect pcm_capture_indirect;
-    atomic_t dma_capture_offset; // to be used with atomic_read, atomic_set 
+    uint32_t dma_playback_offset;
+    uint32_t dma_capture_offset;
+
+    unsigned int pcm_playback_buffer_size;
+    unsigned int pcm_capture_buffer_size;
+
+    uint8_t *dma_playback_buffer;
+    uint8_t *dma_capture_buffer;
 };
 
 
@@ -512,13 +499,28 @@
 }
 static uint32_t mr_alsa_audio_get_playback_buffer_size_in_frames(void *rawchip)
 {
-    if(rawchip)
-    {
-        struct mr_alsa_audio_chip *chip = (struct mr_alsa_audio_chip*)rawchip;
-        if(chip->playback_buffer)
-            return MR_ALSA_RINGBUFFER_NB_FRAMES;
-    }
-    return 0;
+    uint32_t res = 0;
+    if (rawchip)
+    {
+        struct mr_alsa_audio_chip* chip = (struct mr_alsa_audio_chip*)rawchip;
+        //spin_lock_irq(&chip->lock);
+        {
+            struct snd_pcm_runtime* runtime = chip->playback_substream ? chip->playback_substream->runtime : NULL;
+            if (chip->playback_buffer)
+            {
+                if (runtime && runtime->period_size != 0 && runtime->periods != 0)
+                {
+                    res = chip->current_dsd ? MR_ALSA_RINGBUFFER_NB_FRAMES : runtime->period_size * runtime->periods;
+                }
+                else
+                {
+                    res = MR_ALSA_RINGBUFFER_NB_FRAMES;
+                }
+            }
+        }
+        //spin_unlock_irq(&chip->lock);
+    }
+    return res;
 
 }
 static void* mr_alsa_audio_get_capture_buffer(void *rawchip)
@@ -599,10 +601,12 @@
         uint32_t ring_buffer_size = MR_ALSA_RINGBUFFER_NB_FRAMES; // init to the max size possible
         uint32_t ptp_frame_size;
         struct mr_alsa_audio_chip *chip = (struct mr_alsa_audio_chip*)rawchip;
-        spin_lock_irq(&chip->lock);
+
+        spin_lock(&chip->lock);
         chip->mr_alsa_audio_ops->get_interrupts_frame_size(chip->ravenna_peer, &ptp_frame_size);
         if(direction == 1 && chip->capture_substream != NULL)
         {
+            unsigned long bytes_to_frame_factor;
             struct snd_pcm_runtime *runtime = chip->capture_substream->runtime;
             ring_buffer_size = chip->current_dsd ? MR_ALSA_RINGBUFFER_NB_FRAMES : runtime->period_size * runtime->periods;
             if (ring_buffer_size > MR_ALSA_RINGBUFFER_NB_FRAMES)
@@ -612,28 +616,19 @@
             }
             
             /// DMA case
-            if (runtime->access == SNDRV_PCM_ACCESS_MMAP_INTERLEAVED || 
-                runtime->access == SNDRV_PCM_ACCESS_MMAP_NONINTERLEAVED || 
-                runtime->access == SNDRV_PCM_ACCESS_MMAP_COMPLEX)
-            {
-                unsigned long bytes_to_frame_factor = runtime->channels * snd_pcm_format_physical_width(runtime->format) >> 3;
-                unsigned int pcm_buffer_size = snd_pcm_lib_buffer_bytes(chip->capture_substream);
-                unsigned int pos;
-                uint32_t offset = 0;
-                // char jitter_buffer_byte_len = 3;
-                // chip->mr_alsa_audio_ops->get_jitter_buffer_sample_bytelength(chip->ravenna_peer, &jitter_buffer_byte_len);
-                
-                pos = atomic_read(&chip->dma_capture_offset);
-                pos += ptp_frame_size * bytes_to_frame_factor;
-                if (pos >= pcm_buffer_size)
-                {
-                    pos -= pcm_buffer_size;
-                }
-                atomic_set(&chip->dma_capture_offset, pos);
-                
-                chip->mr_alsa_audio_ops->get_input_jitter_buffer_offset(chip->ravenna_peer, &offset);
-                //printk(KERN_DEBUG "Interrupt Capture pos = %u \n", offset);
-            }
+            bytes_to_frame_factor = runtime->channels * chip->current_alsa_capture_stride;
+
+            //printk(KERN_DEBUG "capture copy pos=%u, dma_pos=%u, count=%u, channels=%d pcm_size=%u\n", chip->capture_buffer_pos, pos, ptp_frame_size, runtime->channels, pcm_buffer_size);
+            mr_alsa_audio_pcm_capture_copy_internal(chip->capture_substream, runtime->channels/*channel*/,
+                chip->capture_buffer_pos, chip->dma_capture_buffer + chip->dma_capture_offset/**src*/, ptp_frame_size);
+
+            chip->dma_capture_offset += ptp_frame_size * bytes_to_frame_factor;
+            if (chip->dma_capture_offset >= chip->pcm_capture_buffer_size)
+                chip->dma_capture_offset -= chip->pcm_capture_buffer_size;
+
+            chip->capture_buffer_pos += ptp_frame_size;
+            if(chip->capture_buffer_pos >= ring_buffer_size)
+                chip->capture_buffer_pos -= ring_buffer_size;
             
             /// Ravenna DSD always uses a rate of 352k with eventual zero padding to maintain a 32 bit alignment
             /// while DSD in ALSA uses a continuous 8, 16 or 32 bit aligned stream with at 352k, 176k or 88k
@@ -641,11 +636,14 @@
             if(++chip->current_capture_interrupt_idx >= chip->nb_capture_interrupts_per_period)
             {
                 chip->current_capture_interrupt_idx = 0;
+                spin_unlock(&chip->lock);
                 snd_pcm_period_elapsed(chip->capture_substream);
+                spin_lock(&chip->lock);
             }
         }
         else if(direction == 0 && chip->playback_substream != NULL)
         {
+            unsigned long bytes_to_frame_factor;
             struct snd_pcm_runtime *runtime = chip->playback_substream->runtime;
             ring_buffer_size = chip->current_dsd ? MR_ALSA_RINGBUFFER_NB_FRAMES : runtime->period_size * runtime->periods;
             if (ring_buffer_size > MR_ALSA_RINGBUFFER_NB_FRAMES)
@@ -653,27 +651,18 @@
                 printk(KERN_ERR "mr_alsa_audio_pcm_interrupt playback period_size*periods > MR_ALSA_RINGBUFFER_NB_FRAMES\n");
                 return -2;
             }
-            
-            /// DMA case
-            if (runtime->access == SNDRV_PCM_ACCESS_MMAP_INTERLEAVED || 
-                runtime->access == SNDRV_PCM_ACCESS_MMAP_NONINTERLEAVED || 
-                runtime->access == SNDRV_PCM_ACCESS_MMAP_COMPLEX)
-            {
-                unsigned long bytes_to_frame_factor = runtime->channels * snd_pcm_format_physical_width(runtime->format) >> 3;
-                unsigned int pcm_buffer_size = snd_pcm_lib_buffer_bytes(chip->playback_substream);
-                unsigned int pos;
-                
-                pos = atomic_read(&chip->dma_playback_offset);
-                pos += ptp_frame_size * bytes_to_frame_factor;
-                if (pos >= pcm_buffer_size)
-                {
-                    pos -= pcm_buffer_size;
-                }
-                atomic_set(&chip->dma_playback_offset, pos);
-            }
-            
+
+            bytes_to_frame_factor = runtime->channels * chip->current_alsa_playback_stride;
+            //printk(KERN_DEBUG "playback copy pos=%u, dma_pos=%u, count=%u, channels=%d pcm_size=%u\n", chip->playback_buffer_pos, pos, ptp_frame_size, runtime->channels, pcm_buffer_size);
+            mr_alsa_audio_pcm_playback_copy_internal(chip->playback_substream, runtime->channels/*channel*/,
+                chip->playback_buffer_pos/*pos*/, chip->dma_playback_buffer + chip->dma_playback_offset/*src*/, ptp_frame_size/*count*/);
+
+            chip->dma_playback_offset += ptp_frame_size * bytes_to_frame_factor;
+            if (chip->dma_playback_offset >= chip->pcm_playback_buffer_size)
+                chip->dma_playback_offset -= chip->pcm_playback_buffer_size;
+
             chip->playback_buffer_pos += ptp_frame_size;
-            if(chip->playback_buffer_pos >= ring_buffer_size)
+            if (chip->playback_buffer_pos >= ring_buffer_size)
                 chip->playback_buffer_pos -= ring_buffer_size;
 
             /// Ravenna DSD always uses a rate of 352k with eventual zero padding to maintain a 32 bit alignment
@@ -683,10 +672,12 @@
             {
                 chip->playback_buffer_rav_sac += ptp_frame_size;
                 chip->current_playback_interrupt_idx = 0;
+                spin_unlock(&chip->lock);
                 snd_pcm_period_elapsed(chip->playback_substream);
+                spin_lock(&chip->lock);
             }
         }
-        spin_unlock_irq(&chip->lock);
+        spin_unlock(&chip->lock);
         return 0;
     }
     return -1;
@@ -923,17 +914,14 @@
             /// Fill the additional delay between the packet output and the sound eared
             chip->mr_alsa_audio_ops->get_playout_delay(chip->ravenna_peer, &runtime->delay);
 
-            // TODO: snd_pcm_format_set_silence(SNDRV_PCM_FORMAT_S24_3LE, chip->mr_alsa_audio_ops->, )
-
-            atomic_set(&chip->dma_playback_offset, 0);
-            memset(&chip->pcm_playback_indirect, 0, sizeof(chip->pcm_playback_indirect));
-            chip->pcm_playback_indirect.hw_buffer_size = chip->pcm_playback_indirect.sw_buffer_size = snd_pcm_lib_buffer_bytes(substream);
+            chip->dma_playback_offset = 0;
+            chip->dma_playback_buffer = runtime->dma_area;
+            chip->pcm_playback_buffer_size = snd_pcm_lib_buffer_bytes(chip->playback_substream);
         }
         else if(substream->stream == SNDRV_PCM_STREAM_CAPTURE)
         {
             uint32_t offset = 0;
             chip->mr_alsa_audio_ops->get_input_jitter_buffer_offset(chip->ravenna_peer, &offset);
-            
             
             printk(KERN_DEBUG "mr_alsa_audio_pcm_prepare for capture stream\n");
             if(chip->ravenna_peer)
@@ -952,12 +940,10 @@
             chip->capture_buffer_pos = offset;
             chip->current_capture_interrupt_idx = 0;
             chip->nb_capture_interrupts_per_period = ((runtime_dsd_mode != 0)? (MR_ALSA_PTP_FRAME_RATE_FOR_DSD / runtime->rate) : 1);
-            // TODO: snd_pcm_format_set_silence
             
-            atomic_set(&chip->dma_capture_offset, 0);
-            memset(&chip->pcm_capture_indirect, 0, sizeof(chip->pcm_capture_indirect));
-            chip->pcm_capture_indirect.hw_buffer_size = snd_pcm_lib_buffer_bytes(substream);
-            chip->pcm_capture_indirect.sw_buffer_size = snd_pcm_lib_buffer_bytes(substream);
+            chip->dma_capture_offset = 0;
+            chip->dma_capture_buffer = runtime->dma_area;
+            chip->pcm_capture_buffer_size = snd_pcm_lib_buffer_bytes(chip->capture_substream);
         }
     }
     else
@@ -979,19 +965,13 @@
     uint32_t offset = 0;
     //printk("entering mr_alsa_audio_pcm_pointer (substream name=%s #%d) ...\n", alsa_sub->name, alsa_sub->number);
 
+    spin_lock(&chip->lock);
     if(alsa_sub->stream == SNDRV_PCM_STREAM_PLAYBACK)
     {
         /// DMA case
-        if (alsa_sub->runtime->access == SNDRV_PCM_ACCESS_MMAP_INTERLEAVED || 
-            alsa_sub->runtime->access == SNDRV_PCM_ACCESS_MMAP_NONINTERLEAVED || 
-            alsa_sub->runtime->access == SNDRV_PCM_ACCESS_MMAP_COMPLEX)
-        {
-            offset = snd_pcm_indirect_playback_pointer(alsa_sub, &chip->pcm_playback_indirect, atomic_read(&chip->dma_playback_offset));
-        }
-        else
-        {
-            offset = chip->playback_buffer_pos;
-        }
+        struct snd_pcm_runtime *runtime = alsa_sub->runtime;
+        unsigned long bytes_to_frame_factor = runtime->channels * chip->current_alsa_playback_stride;
+        offset = chip->dma_playback_offset / bytes_to_frame_factor;
 
         /// Ravenna DSD always uses a rate of 352k with eventual zero padding to maintain a 32 bit alignment
         /// while DSD in ALSA uses a continuous 8, 16 or 32 bit aligned stream with at 352k, 176k or 88k
@@ -1014,17 +994,9 @@
     }
     else if(alsa_sub->stream == SNDRV_PCM_STREAM_CAPTURE)
     {
-        /// DMA case
-        if (alsa_sub->runtime->access == SNDRV_PCM_ACCESS_MMAP_INTERLEAVED || 
-            alsa_sub->runtime->access == SNDRV_PCM_ACCESS_MMAP_NONINTERLEAVED || 
-            alsa_sub->runtime->access == SNDRV_PCM_ACCESS_MMAP_COMPLEX)
-        {
-            offset = snd_pcm_indirect_capture_pointer(alsa_sub, &chip->pcm_capture_indirect, atomic_read(&chip->dma_capture_offset));
-        }
-        else
-        {
-            chip->mr_alsa_audio_ops->get_input_jitter_buffer_offset(chip->ravenna_peer, &offset);
-        }
+        struct snd_pcm_runtime *runtime = alsa_sub->runtime;
+        unsigned long bytes_to_frame_factor = runtime->channels * chip->current_alsa_capture_stride;
+        offset = chip->dma_capture_offset / bytes_to_frame_factor;
 
         /// Ravenna DSD always uses a rate of 352k with eventual zero padding to maintain a 32 bit alignment
         /// while DSD in ALSA uses a continuous 8, 16 or 32 bit aligned stream with at 352k, 176k or 88k
@@ -1045,6 +1017,7 @@
         }
         //printk("mr_alsa_audio_pcm_pointer capture offset = %u\n", offset);
     }
+    spin_unlock(&chip->lock);
     return offset;
 }
 
@@ -1155,82 +1128,34 @@
 };
 
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,13,0)
-static int mr_alsa_audio_pcm_capture_copy_user(  struct snd_pcm_substream *substream,
-                                            int channel, unsigned long pos,
-                                            void __user *src,
-                                            unsigned long count)
- {
-    struct snd_pcm_runtime *runtime = substream->runtime;
-    bool interleaved = (runtime->access == SNDRV_PCM_ACCESS_RW_INTERLEAVED) || (runtime->access == SNDRV_PCM_ACCESS_MMAP_INTERLEAVED) ? 1 : 0;
-    unsigned long bytes_to_frame_factor = runtime->channels * snd_pcm_format_physical_width(runtime->format) >> 3;
-    return mr_alsa_audio_pcm_capture_copy(substream, interleaved ? -1 : channel, pos / bytes_to_frame_factor, src, count / bytes_to_frame_factor);
-}
-#endif
-
-static int mr_alsa_audio_pcm_capture_copy(  struct snd_pcm_substream *substream,
-                                            int channel, snd_pcm_uframes_t pos,
-                                            void __user *src,
-                                            snd_pcm_uframes_t count)
-{
-    struct mr_alsa_audio_chip *chip = snd_pcm_substream_chip(substream);
-    uint32_t ravenna_buffer_pos = pos * chip->nb_capture_interrupts_per_period;
-    
-    return mr_alsa_audio_pcm_capture_copy_internal(substream, channel, ravenna_buffer_pos, src, count, true);
-}
-
 static int mr_alsa_audio_pcm_capture_copy_internal(  struct snd_pcm_substream *substream,
                                             int channel, uint32_t pos,
                                             void __user *src,
-                                            snd_pcm_uframes_t count, bool to_user_space)
+                                            snd_pcm_uframes_t count)
 {
     struct mr_alsa_audio_chip *chip = snd_pcm_substream_chip(substream);
     struct snd_pcm_runtime *runtime = substream->runtime;
-    int interleaved = (runtime->access == SNDRV_PCM_ACCESS_RW_INTERLEAVED) || (runtime->access == SNDRV_PCM_ACCESS_MMAP_INTERLEAVED) ? 1 : 0;
+    bool interleaved = (runtime->access == SNDRV_PCM_ACCESS_RW_INTERLEAVED || runtime->access == SNDRV_PCM_ACCESS_MMAP_INTERLEAVED);
     unsigned int nb_logical_bits = snd_pcm_format_width(runtime->format);
-    unsigned int strideIn = snd_pcm_format_physical_width(runtime->format) >> 3;
+    unsigned int strideIn = chip->current_alsa_capture_stride;
     uint32_t ravenna_buffer_pos = pos;
 
-    // todo DSD capture
-    //uint32_t dsdrate = mr_alsa_audio_get_dsd_sample_rate(runtime->format, runtime->rate);
-    //uint32_t dsdmode = (dsdrate > 0? mr_alsa_audio_get_dsd_mode(dsdrate) : 0);
-
-
-    /// Ravenna DSD always uses a rate of 352k with eventual zero padding to maintain a 32 bit alignment
-    /// while DSD in ALSA uses a continuous 8, 16 or 32 bit aligned stream with at 352k, 176k or 88k
-    /// so respective ring buffers might have different scale and size
-    //uint32_t alsa_ring_buffer_nb_frames = MR_ALSA_RINGBUFFER_NB_FRAMES / chip->nb_capture_interrupts_per_period;
-
-    //printk("entering mr_alsa_audio_pcm_capture_copy (channel=%d, count=%lu) (substream name=%s #%d) ...\n", channel, count, substream->name, substream->number);
-    //printk("Bitwidth = %u, strideIn = %u\n", nb_logical_bits, strideIn);
-
-    //if(snd_BUG_ON(ravenna_buffer_pos >= MR_ALSA_RINGBUFFER_NB_FRAMES))
-    //    ravenna_buffer_pos -= MR_ALSA_RINGBUFFER_NB_FRAMES;
-
-
-    //printk("capture_copy: rate = %u, dsdmode = %u, #IRQ per period = %u, count = %lu, pos = %lu, ravenna_buffer_pos = %u\n", (dsdrate > 0? dsdrate : runtime->rate), dsdmode, chip->nb_capture_interrupts_per_period, count, pos, ravenna_buffer_pos);
-    //printk("capture_copy: rate = %u, #IRQ per period = %u, count = %zu, pos = %u, ravenna_buffer_pos = %u, channels = %u\n", runtime->rate, chip->nb_capture_interrupts_per_period, count, pos, ravenna_buffer_pos, runtime->channels);
-
-
     if(interleaved)
     {
-        int ret_pu;
-        char val = 0xf1;
-        ret_pu = __put_user(val, (char *)src);
         switch(nb_logical_bits)
         {
             case 16:
-                MTConvertMappedInt32ToInt16LEInterleave(chip->capture_buffer_channels_map, ravenna_buffer_pos, src, runtime->channels, count, to_user_space);
+                MTConvertMappedInt32ToInt16LEInterleave(chip->capture_buffer_channels_map, ravenna_buffer_pos, src, runtime->channels, count);
                 break;
             case 24:
             {
                 switch(strideIn)
                 {
                     case 3:
-                        MTConvertMappedInt32ToInt24LEInterleave(chip->capture_buffer_channels_map, ravenna_buffer_pos, src, runtime->channels, count, to_user_space);
+                        MTConvertMappedInt32ToInt24LEInterleave(chip->capture_buffer_channels_map, ravenna_buffer_pos, src, runtime->channels, count);
                     break;
                     case 4:
-                        MTConvertMappedInt32ToInt24LE4ByteInterleave(chip->capture_buffer_channels_map, ravenna_buffer_pos, src, runtime->channels, count, to_user_space);
+                        MTConvertMappedInt32ToInt24LE4ByteInterleave(chip->capture_buffer_channels_map, ravenna_buffer_pos, src, runtime->channels, count);
                     break;
                     default:
                     {
@@ -1241,7 +1166,7 @@
                 break;
             }
             case 32:
-                MTConvertMappedInt32ToInt32LEInterleave(chip->capture_buffer_channels_map, ravenna_buffer_pos, src, runtime->channels, count, to_user_space);
+                MTConvertMappedInt32ToInt32LEInterleave(chip->capture_buffer_channels_map, ravenna_buffer_pos, src, runtime->channels, count);
                 break;
         }
     }
@@ -1251,46 +1176,9 @@
         return -EINVAL;
     }
     return count;
-
-}
-/// This callback is called whenever the alsa application wants to write data
-/// We use it here to do all the de-interleaving, format conversion and DSD re-packing
-/// The intermediate buffer is actually the alsa (dma) buffer, allocated in hw_params()
-/// The incoming data (src) is user land memory pointer, so copy_from_user() must be used for memory copy
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,13,0)
-static int mr_alsa_audio_pcm_playback_copy_user(  struct snd_pcm_substream *substream,
-                                            int channel, unsigned long pos,
-                                            void __user *src,
-                                            unsigned long count)
-{
-    struct snd_pcm_runtime *runtime = substream->runtime;
-    bool interleaved = (runtime->access == SNDRV_PCM_ACCESS_RW_INTERLEAVED) || (runtime->access == SNDRV_PCM_ACCESS_MMAP_INTERLEAVED) ? 1 : 0;
-    unsigned long bytes_to_frame_factor = runtime->channels * snd_pcm_format_physical_width(runtime->format) >> 3;
-    return mr_alsa_audio_pcm_playback_copy(substream, interleaved ? -1 : channel, pos / bytes_to_frame_factor, src, count / bytes_to_frame_factor);
-}
-#endif
-
-/// This callback is called whenever the alsa application wants to write data
-/// We use it here to do all the de-interleaving, format conversion and DSD re-packing
-/// The intermediate buffer is actually the alsa (dma) buffer, allocated in hw_params()
-/// The incoming data (src) is user land memory pointer, so copy_from_user() must be used for memory copy
-static int mr_alsa_audio_pcm_playback_copy( struct snd_pcm_substream *substream,
-                                            int channel, snd_pcm_uframes_t pos,
-                                            void __user *src,
-                                            snd_pcm_uframes_t count)
-{
-    struct mr_alsa_audio_chip *chip = snd_pcm_substream_chip(substream);
-    /// Ravenna DSD always uses a rate of 352k with eventual zero padding to maintain a 32 bit alignment
-    /// while DSD in ALSA uses a continuous 8, 16 or 32 bit aligned stream with at 352k, 176k or 88k
-    /// so respective ring buffers might have different scale and size
-    uint32_t ravenna_buffer_pos = pos * chip->nb_playback_interrupts_per_period;
-    
-    if(snd_BUG_ON(ravenna_buffer_pos >= MR_ALSA_RINGBUFFER_NB_FRAMES))
-        ravenna_buffer_pos -= MR_ALSA_RINGBUFFER_NB_FRAMES;
-    
-    return mr_alsa_audio_pcm_playback_copy_internal(substream, channel, ravenna_buffer_pos, src, count);
-}
-///
+}
+
+
 static int mr_alsa_audio_pcm_playback_copy_internal( struct snd_pcm_substream *substream,
                                             int channel, uint32_t pos,
                                             void __user *src,
@@ -1299,491 +1187,100 @@
     struct mr_alsa_audio_chip *chip = snd_pcm_substream_chip(substream);
     struct snd_pcm_runtime *runtime = substream->runtime;
     int chn = 0;
-    int interleaved = (runtime->access == SNDRV_PCM_ACCESS_RW_INTERLEAVED) || (runtime->access == SNDRV_PCM_ACCESS_MMAP_INTERLEAVED) ? 1 : 0;
+    bool interleaved = (runtime->access == SNDRV_PCM_ACCESS_RW_INTERLEAVED || runtime->access == SNDRV_PCM_ACCESS_MMAP_INTERLEAVED);
     unsigned int nb_logical_bits = snd_pcm_format_width(runtime->format);
-    unsigned int strideIn = snd_pcm_format_physical_width(runtime->format) >> 3;
+    unsigned int strideIn = chip->current_alsa_playback_stride;
     unsigned int strideOut = snd_pcm_format_physical_width(SNDRV_PCM_FORMAT_S32_LE) >> 3;
     uint32_t dsdrate = mr_alsa_audio_get_dsd_sample_rate(runtime->format, runtime->rate);
     uint32_t dsdmode = (dsdrate > 0? mr_alsa_audio_get_dsd_mode(dsdrate) : 0);
     uint32_t ravenna_buffer_pos = pos;
-    //uint32_t alsa_ring_buffer_nb_frames = MR_ALSA_RINGBUFFER_NB_FRAMES / chip->nb_playback_interrupts_per_period;
-
-    #ifdef MUTE_CHECK
-        // mute check
-        unsigned char *buffer_to_check = chip->playback_buffer + ravenna_buffer_pos * strideOut; // output buffer channel 0
-        bool mute_detected = false;
-        char testblock [256];
-        memset(testblock, 0, sizeof(testblock));
-    #endif
-    
-    if (channel > 0 && channel >= runtime->channels)
-    {
-        printk(KERN_WARNING "Channel %d copy ignored because it does not fit the available runtime channels (%d)", channel, runtime->channels);
-       return 0;
-    }
-
-    //printk(KERN_DEBUG "entering mr_alsa_audio_pcm_playback_copy (substream name=%s #%d) (runtime channels %d) access %d...\n", substream->name, substream->number, runtime->channels, runtime->access));
-
-    /*if(snd_BUG_ON(chip->playback_buffer_rav_sac > chip->playback_buffer_alsa_sac))
-    {
-        printk(KERN_WARNING "mr_alsa_audio_pcm_playback_copy: Playback stall. Missing playback data from the player application.");
-        return -EINVAL;
-    }
-
-    //printk("playback_copy: initial count = %u, alsa_ring_buffer_nb_frames = %u \n", count, alsa_ring_buffer_nb_frames);
-    if(alsa_ring_buffer_nb_frames < chip->playback_buffer_alsa_sac - chip->playback_buffer_rav_sac)
-    {
-        count = 0; /// no room for more playback at the moment
-        printk(KERN_WARNING "playback_copy: no room at the moment (count =%lu) \n", count);
-    }
-
-    if(count > alsa_ring_buffer_nb_frames - (chip->playback_buffer_alsa_sac - chip->playback_buffer_rav_sac))
-    {
-        snd_pcm_uframes_t new_count = (snd_pcm_uframes_t)(alsa_ring_buffer_nb_frames - (chip->playback_buffer_alsa_sac - chip->playback_buffer_rav_sac));
-        printk(KERN_WARNING "playback_copy count overflow 1: change count from %lu to %lu\n", count, new_count);
-        count = new_count;
-    }
-    if(count * chip->nb_playback_interrupts_per_period + ravenna_buffer_pos > MR_ALSA_RINGBUFFER_NB_FRAMES)
-    {
-        snd_pcm_uframes_t new_count = (MR_ALSA_RINGBUFFER_NB_FRAMES - ravenna_buffer_pos) / chip->nb_playback_interrupts_per_period;
-        printk(KERN_WARNING "playback_copy count overflow 2: change count from %lu to %lu\n", count, new_count);
-        count = new_count;
-    }*/
-
-    //printk("playback_copy: rate = %u, dsdmode = %u, #IRQ per period = %u, count = %u, pos = %lu, ravenna_buffer_pos = %u, alsa_pb_sac = %llu, ravenna_pb_sac = %llu\n", (dsdrate > 0? dsdrate : runtime->rate), dsdmode, chip->nb_playback_interrupts_per_period, count, pos, ravenna_buffer_pos, chip->playback_buffer_alsa_sac, chip->playback_buffer_rav_sac);
-    if(count == 0)
-        return 0;
-    
+
     if(interleaved)
     {
-        {
-            /// de-interleaving
-            unsigned char *in, *out;
-            unsigned int stepIn = runtime->channels * strideIn;
-            unsigned int stepOut = strideOut * chip->nb_playback_interrupts_per_period;
-            size_t ravBuffer_csize = MR_ALSA_RINGBUFFER_NB_FRAMES * strideOut;
-            //printk("playback_copy: de-interleaving %u frames, pos = %llu, ravenna_buffer_pos = %u, with strideIn = %u, strideOut = %u, stepIn = %u, stepOut = %u, ravBuffer_csize = %u \n", count, pos, ravenna_buffer_pos, strideIn, strideOut, stepIn, stepOut, (unsigned int)ravBuffer_csize);
-            for(chn = 0; chn < runtime->channels; ++chn)
+        /// de-interleaving
+        unsigned char *in, *out;
+        unsigned int stepIn = runtime->channels * strideIn;
+        unsigned int stepOut = strideOut * chip->nb_playback_interrupts_per_period;
+        uint32_t ring_buffer_size = MR_ALSA_RINGBUFFER_NB_FRAMES * strideOut;
+
+        for (chn = 0; chn < runtime->channels; ++chn)
+        {
+            uint32_t currentOutPos = ravenna_buffer_pos * strideOut;
+            snd_pcm_uframes_t frmCnt = 0;
+            in = (unsigned char*)src + chn * strideIn;
+            out = chip->playback_buffer + chn * ring_buffer_size + currentOutPos;
+            //
+            ///Conversion to Signed integer 32 bit LE
+            for (frmCnt = 0; frmCnt < count; ++frmCnt)
             {
-                uint32_t currentOutPos = ravenna_buffer_pos * strideOut;
-                snd_pcm_uframes_t frmCnt = 0;
-                in = (unsigned char*)src + chn * strideIn;
-                out = chip->playback_buffer + chn * ravBuffer_csize + currentOutPos;
-
-                ///Conversion to Signed integer 32 bit LE
-                for(frmCnt = 0; frmCnt < count; ++frmCnt)
+                /// assumes Little Endian
+                if (dsdmode == 0)
                 {
-                    /// assumes Little Endian
-                    int32_t val = 0;
-                    if(dsdmode == 0)
+                    switch (nb_logical_bits)
                     {
-                        switch(nb_logical_bits)
+                    case 16:
+                        out[3] = in[1];
+                        out[2] = in[0];
+                        out[1] = 0;
+                        out[0] = 0;
+                        break;
+                    case 24:
+                        out[3] = in[2];
+                        out[2] = in[1];
+                        out[1] = in[0];
+                        out[0] = 0;
+                        break;
+                    case 32:
+                        *(int32_t*)out = *(int32_t*)in;
+                        break;
+                    }
+                }
+                else
+                {
+                    /// interleaved DSD stream to non interleaved 32 bit aligned blocks with 1/2/4 DSD bytes per 32 bit
+                    uint32_t out_cnt;
+                    for (out_cnt = 0; out_cnt < chip->nb_playback_interrupts_per_period; ++out_cnt)
+                    {
+                        switch (dsdmode)
                         {
-                            case 16:
-                                //val = (((int32_t)(in[1]) << 8) | ((int32_t)(in[0]))) << 16;
-                                // OR
-                                //((unsigned char*)&val)[3] = in[1];
-                                //((unsigned char*)&val)[2] = in[0];
-                                // OR without intermediate copy_from_user buffer
-                                __get_user(((unsigned char*)&val)[3], &in[1]);
-                                __get_user(((unsigned char*)&val)[2], &in[0]);
-                                break;
-                            case 24:
-                                //val = (((int32_t)(in[2]) << 16) | ((int32_t)(in[1]) << 8) | ((int32_t)(in[0]))) << 8;
-                                // OR
-                                // ((unsigned char*)&val)[3] = in[2];
-                                // ((unsigned char*)&val)[2] = in[1];
-                                // ((unsigned char*)&val)[1] = in[0];
-                                // OR without intermediate copy_from_user buffer
-                                __get_user(((unsigned char*)&val)[3], &in[2]);
-                                __get_user(((unsigned char*)&val)[2], &in[1]);
-                                __get_user(((unsigned char*)&val)[1], &in[0]);
-                                break;
-                            case 32:
-                                //val = *(int32_t*)(in);
-                                // OR without intermediate copy_from_user buffer
-                                __get_user(val, (int32_t*)in);
-                                break;
-                        }
-                        *((int32_t*)out) = val;
-                    }
-                    else
-                    {
-                        /// interleaved DSD stream to non interleaved 32 bit aligned blocks with 1/2/4 DSD bytes per 32 bit
-                        uint32_t out_cnt;
-                        for(out_cnt = 0; out_cnt < chip->nb_playback_interrupts_per_period; ++out_cnt)
-                        {
-                            switch(dsdmode)
-                            {
-                                case 1: ///DSD64
-                                    //val = *(int32_t*)(in + out_cnt) & 0xFF;
-                                    __get_user(((unsigned char*)&val)[0], &in[out_cnt]);
-                                    break;
-                                case 2: ///DSD128
-                                    //val = (((int32_t)(in[2 * out_cnt + 1]) << 8) | ((int32_t)(in[2 * out_cnt]))) & 0xFFFF;
-                                    __get_user(((unsigned char*)&val)[1], &in[2 * out_cnt + 1]);
-                                    __get_user(((unsigned char*)&val)[0], &in[2 * out_cnt]);
-                                    break;
-                                case 4: ///DSD256
-                                    //val = *(int32_t*)(in);
-                                    // OR without intermediate copy_from_user buffer
-                                    __get_user(val, (int32_t*)in);
-                                    break;
-                            }
-                            ((int32_t*)out)[out_cnt] = val;
+                        case 1: ///DSD64
+                            ((int32_t*)out)[out_cnt] = *(int32_t*)(in + out_cnt) & 0xFF;
+                            break;
+                            case 2: ///DSD128
+                            ((int32_t*)out)[out_cnt] = (((int32_t)(in[2 * out_cnt + 1]) << 8) | ((int32_t)(in[2 * out_cnt]))) & 0xFFFF;
+                            break;
+                        case 4: ///DSD256
+                            ((int32_t*)out)[out_cnt] = *(int32_t*)(in);
+                            break;
                         }
                     }
-
-                    in += stepIn;
-                    if(currentOutPos + stepOut >= ravBuffer_csize)
-                    {
-                        currentOutPos = 0;
-                        out = chip->playback_buffer + chn * ravBuffer_csize;
-                    }
-                    else
-                    {
-                        currentOutPos += stepOut;
-                        out += stepOut;
-                    }
+                }
+
+                in += stepIn;
+                if (currentOutPos + stepOut >= ring_buffer_size)
+                {
+                    currentOutPos = 0;
+                    out = chip->playback_buffer + chn * ring_buffer_size;
+                }
+                else
+                {
+                    currentOutPos += stepOut;
+                    out += stepOut;
                 }
             }
         }
     }
     else
     {
-        {
-            //printk("mr_alsa_audio_pcm_playback_copy: no de-interleaving, converting %u frames with strideIn = %u\n", count, strideIn);
-            /// do the format conversion to the Ravenna Ring buffer
-            {
-                unsigned char *in, *out;
-                unsigned int stepIn = strideIn;
-                unsigned int stepOut = strideOut * chip->nb_playback_interrupts_per_period;
-                size_t ravBuffer_csize = MR_ALSA_RINGBUFFER_NB_FRAMES * strideOut;
-                uint32_t currentOutPos = ravenna_buffer_pos * strideOut;
-                snd_pcm_uframes_t frmCnt = 0;
-
-                in = (unsigned char*)src;
-                out = chip->playback_buffer + channel * ravBuffer_csize + currentOutPos;
-                for(frmCnt = 0; frmCnt < count; ++frmCnt)
-                {
-                    /// conversion to signed 32 bit integer LE
-                    /// assumes Little Endian
-                     int32_t val = 0;
-                    if(dsdmode == 0)
-                    {
-                        switch(nb_logical_bits)
-                        {
-                            case 16:
-                                //val = (((int32_t)(in[1]) << 8) | ((int32_t)(in[0]))) << 16;
-                                // OR
-                                //((unsigned char*)&val)[3] = in[1];
-                                //((unsigned char*)&val)[2] = in[0];
-                                // OR without intermediate copy_from_user buffer
-                                __get_user(((unsigned char*)&val)[3], &in[1]);
-                                __get_user(((unsigned char*)&val)[2], &in[0]);
-                                break;
-                            case 24:
-                                //val = (((int32_t)(in[2]) << 16) | ((int32_t)(in[1]) << 8) | ((int32_t)(in[0]))) << 8;
-                                // OR
-                                // ((unsigned char*)&val)[3] = in[2];
-                                // ((unsigned char*)&val)[2] = in[1];
-                                // ((unsigned char*)&val)[1] = in[0];
-                                // OR without intermediate copy_from_user buffer
-                                __get_user(((unsigned char*)&val)[3], &in[2]);
-                                __get_user(((unsigned char*)&val)[2], &in[1]);
-                                __get_user(((unsigned char*)&val)[1], &in[0]);
-                                break;
-                            case 32:
-                                //val = *(int32_t*)(in);
-                                // OR without intermediate copy_from_user buffer
-                                __get_user(val, (int32_t*)in);
-                                break;
-                        }
-                        *((int32_t*)out) = val;
-                    }
-                    else
-                    {
-                        /// interleaved DSD stream to non interleaved 32 bit aligned blocks with 1/2/4 DSD bytes per 32 bit
-                        uint32_t out_cnt;
-                        for(out_cnt = 0; out_cnt < chip->nb_playback_interrupts_per_period; ++out_cnt)
-                        {
-                            switch(dsdmode)
-                            {
-                                case 1: ///DSD64
-                                    //val = *(int32_t*)(in + out_cnt) & 0xFF;
-                                    __get_user(((unsigned char*)&val)[0], &in[out_cnt]);
-                                    break;
-                                case 2: ///DSD128
-                                    //val = (((int32_t)(in[2 * out_cnt + 1]) << 8) | ((int32_t)(in[2 * out_cnt]))) & 0xFFFF;
-                                    __get_user(((unsigned char*)&val)[1], &in[2 * out_cnt + 1]);
-                                    __get_user(((unsigned char*)&val)[0], &in[2 * out_cnt]);
-                                    break;
-                                case 4: ///DSD256
-                                    //val = *(int32_t*)(in);
-                                    // OR without intermediate copy_from_user buffer
-                                    __get_user(val, (int32_t*)in);
-                                    break;
-                            }
-                            ((int32_t*)out)[out_cnt] = val;
-                        }
-                    }
-                    in += stepIn;
-                    if(currentOutPos + stepOut >= ravBuffer_csize)
-                    {
-                        currentOutPos = 0;
-                        out = chip->playback_buffer + channel * ravBuffer_csize;
-                    }
-                    else
-                    {
-                        currentOutPos += stepOut;
-                        out += stepOut;
-                    }
-                }
-            }
-        }
-    }
-    
-    
-    #ifdef MUTE_CHECK
-    // First channel check
-    mute_detected = !memcmp(testblock, buffer_to_check, min((ssize_t )256, frames_to_bytes(runtime, count)));
-    if (mute_detected != playback_mute_detected)
-    {
-        if (mute_detected)
-            printk(">>>>Playback buffer mute detected\n");
-        else
-            printk(">>>>Playback buffer signal detected\n");
-        playback_mute_detected = mute_detected;
-    }
-    #endif
+        printk(KERN_WARNING "Uninterleaved Playback is not supported\n");
+        return -EINVAL;
+    }
     
     chip->playback_buffer_alsa_sac += count;
     return count;
 }
 
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,13,0)
-static int mr_alsa_audio_pcm_playback_fill_silence(  struct snd_pcm_substream *substream,
-                                            int channel, unsigned long pos,
-                                            unsigned long count)
-{
-    struct snd_pcm_runtime *runtime = substream->runtime;
-    bool interleaved = (runtime->access == SNDRV_PCM_ACCESS_RW_INTERLEAVED) || (runtime->access == SNDRV_PCM_ACCESS_MMAP_INTERLEAVED) ? 1 : 0;
-    unsigned long bytes_to_frame_factor = runtime->channels * snd_pcm_format_physical_width(runtime->format) >> 3;
-    return mr_alsa_audio_pcm_playback_silence(substream, interleaved ? -1 : channel, pos / bytes_to_frame_factor, count / bytes_to_frame_factor);
-}
-#endif
-
-static int mr_alsa_audio_pcm_playback_silence(  struct snd_pcm_substream *substream,
-                                            int channel, snd_pcm_uframes_t pos,
-                                            snd_pcm_uframes_t count)
-{
-    struct mr_alsa_audio_chip *chip = snd_pcm_substream_chip(substream);
-    struct snd_pcm_runtime *runtime = substream->runtime;
-    unsigned char *out;
-    int interleaved = (runtime->access == SNDRV_PCM_ACCESS_RW_INTERLEAVED) || (runtime->access == SNDRV_PCM_ACCESS_MMAP_INTERLEAVED) ? 1 : 0;
-    //unsigned int strideIn = snd_pcm_format_physical_width(runtime->format) >> 3;
-    unsigned int strideOut = snd_pcm_format_physical_width(SNDRV_PCM_FORMAT_S32_LE) >> 3;
-    size_t ravBuffer_csize = MR_ALSA_RINGBUFFER_NB_FRAMES * strideOut;
-    const unsigned char def_sil_pat[8] = {0,0,0,0,0,0,0,0};
-    const unsigned char *sil_pat = snd_pcm_format_silence_64(runtime->format);
-    const uint32_t dsd_pattern = 0x55555555;
-    uint32_t dsdrate = mr_alsa_audio_get_dsd_sample_rate(runtime->format, runtime->rate);
-    uint32_t dsdmode = (dsdrate > 0? mr_alsa_audio_get_dsd_mode(dsdrate) : 0);
-
-    /// Ravenna DSD always uses a rate of 352k with eventual zero padding to maintain a 32 bit alignment
-    /// while DSD in ALSA uses a continuous 8, 16 or 32 bit aligned stream with at 352k, 176k or 88k
-    /// so respective ring buffers might have different scale and size
-    pos *= chip->nb_playback_interrupts_per_period;
-
-    printk(KERN_DEBUG "mr_alsa_audio_pcm_playback_silence called for %lu frames at pos %lu\n", count, pos);
-
-    if(sil_pat == NULL)
-        sil_pat = &def_sil_pat[0];
-
-    if(interleaved)
-    {
-        /// mute all channels directly in the Ravenna Ring Buffer
-        unsigned int samples = count;
-        int chn = 0;
-        for(chn = 0; chn < runtime->channels; ++chn)
-        {
-            out = chip->playback_buffer + chn * ravBuffer_csize + pos * strideOut;
-            if(dsdmode == 0)
-            {
-                switch (strideOut)
-                {
-                    case 2:
-                        while (samples--) {
-                            memcpy(out, sil_pat, 2);
-                            out += 2;
-                        }
-                        break;
-                    case 3:
-                        while (samples--) {
-                            memcpy(out, sil_pat, 3);
-                            out += 3;
-                        }
-                        break;
-                    case 4:
-                        while (samples--) {
-                            memcpy(out, sil_pat, 4);
-                            out += 4;
-                        }
-                        break;
-                }
-            }
-            else
-            {
-                uint32_t dsdmute = dsd_pattern;
-                switch(dsdmode)
-                {
-                    case 1: ///DSD64
-                        dsdmute = (dsd_pattern & 0xFF);
-                        break;
-                    case 2: ///DSD128
-                        dsdmute = (dsd_pattern & 0xFFFF);
-                        break;
-                }
-                while (samples--)
-                {
-                    memcpy(out, &dsdmute, strideOut);
-                    out += strideOut;
-                }
-            }
-        }
-    }
-    else
-    {
-        /// mute the specified channel in the Ravenna Ring Buffer
-        unsigned int samples = count;
-        out = chip->playback_buffer + channel * ravBuffer_csize + pos * strideOut;
-        if(dsdmode == 0)
-        {
-            switch (strideOut)
-            {
-                case 2:
-                    while (samples--) {
-                        memcpy(out, sil_pat, 2);
-                        out += 2;
-                    }
-                    break;
-                case 3:
-                    while (samples--) {
-                        memcpy(out, sil_pat, 3);
-                        out += 3;
-                    }
-                    break;
-                case 4:
-                    while (samples--) {
-                        memcpy(out, sil_pat, 4);
-                        out += 4;
-                    }
-                    break;
-            }
-        }
-        else
-        {
-            uint32_t dsdmute = dsd_pattern;
-            switch(dsdmode)
-            {
-                case 1: ///DSD64
-                    dsdmute = (dsd_pattern & 0xFF);
-                    break;
-                case 2: ///DSD128
-                    dsdmute = (dsd_pattern & 0xFFFF);
-                    break;
-            }
-            while (samples--)
-            {
-                memcpy(out, &dsdmute, strideOut);
-                out += strideOut;
-            }
-        }
-    }
-    return count;
-}
-
-static void mr_alsa_audio_pcm_capture_ack_transfer(struct snd_pcm_substream *substream, struct snd_pcm_indirect *rec, size_t bytes)
-{
-    struct snd_pcm_runtime *runtime = substream->runtime;
-    struct mr_alsa_audio_chip *chip = snd_pcm_substream_chip(substream);
-    unsigned long bytes_to_frame_factor = runtime->channels * snd_pcm_format_physical_width(runtime->format) >> 3;
-    uint32_t ring_buffer_size = MR_ALSA_RINGBUFFER_NB_FRAMES; // init to the max size possible
-    uint32_t pos = chip->capture_buffer_pos;
-    
-    char jitter_buffer_byte_len = 3;
-    chip->mr_alsa_audio_ops->get_jitter_buffer_sample_bytelength(chip->ravenna_peer, &jitter_buffer_byte_len);
-    
-    ring_buffer_size = chip->current_dsd ? MR_ALSA_RINGBUFFER_NB_FRAMES : runtime->period_size * runtime->periods;
-    
-    //printk(KERN_DEBUG "Transfer Capture pos = %u, size = %zu (ring_buffer_size = %u, bytes_to_frame_factor = %zu, jitter_buffer_byte_len = %d)\n", pos, bytes, ring_buffer_size, bytes_to_frame_factor, jitter_buffer_byte_len);
-    
-    chip->capture_buffer_pos += bytes / bytes_to_frame_factor;
-    if (chip->capture_buffer_pos >= ring_buffer_size)
-    {
-        // unsigned long end_bytes = ring_buffer_size - pos;
-        // unsigned long start_bytes = bytes - end_bytes;
-        
-        // mr_alsa_audio_pcm_capture_copy_internal(chip->capture_substream, 
-            // runtime->access == SNDRV_PCM_ACCESS_MMAP_INTERLEAVED ? -1 : runtime->channels/*channel*/, 
-            // pos, runtime->dma_area + rec->sw_data/**src*/, (end_bytes * jitter_buffer_byte_len) / bytes_to_frame_factor);
-        
-        // mr_alsa_audio_pcm_capture_copy_internal(chip->capture_substream, 
-            // runtime->access == SNDRV_PCM_ACCESS_MMAP_INTERLEAVED ? -1 : runtime->channels/*channel*/, 
-            // 0, runtime->dma_area + rec->sw_data + end_bytes, (start_bytes * jitter_buffer_byte_len) / bytes_to_frame_factor);
-            
-        // memset(runtime->dma_area + rec->sw_data, 0x00, bytes);
-        
-        chip->capture_buffer_pos -= ring_buffer_size;
-        if (chip->capture_buffer_pos != 0)
-            printk(KERN_WARNING "Capture tranfer buffer wrapping to implement");
-    }
-    //else
-    {
-        mr_alsa_audio_pcm_capture_copy_internal(chip->capture_substream, 
-            runtime->access == SNDRV_PCM_ACCESS_MMAP_INTERLEAVED ? -1 : runtime->channels/*channel*/, 
-            pos, runtime->dma_area + rec->sw_data/**src*/, bytes / bytes_to_frame_factor, false);
-    }
-}
-
-static void mr_alsa_audio_pcm_playback_ack_transfer(struct snd_pcm_substream *substream, struct snd_pcm_indirect *rec, size_t bytes)
-{
-	struct snd_pcm_runtime *runtime = substream->runtime;
-    struct mr_alsa_audio_chip *chip = snd_pcm_substream_chip(substream);
-    unsigned long bytes_to_frame_factor = runtime->channels * snd_pcm_format_physical_width(runtime->format) >> 3;
-    
-    mr_alsa_audio_pcm_playback_copy_internal(chip->playback_substream, 
-        runtime->access == SNDRV_PCM_ACCESS_MMAP_INTERLEAVED ? -1 : runtime->channels/*channel*/, 
-        chip->playback_buffer_pos/*pos*/, runtime->dma_area + rec->sw_data/**src*/, bytes / bytes_to_frame_factor/*count*/);
-}
-
-static int mr_alsa_audio_pcm_ack(struct snd_pcm_substream *substream)
-{
-    struct mr_alsa_audio_chip *chip = snd_pcm_substream_chip(substream);
-    
-    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-    {
-        struct snd_pcm_indirect *pcm_indirect = &chip->pcm_playback_indirect;
-    #if LINUX_VERSION_CODE >= KERNEL_VERSION(5,2,0)
-        return snd_pcm_indirect_playback_transfer(substream, pcm_indirect, mr_alsa_audio_pcm_playback_ack_transfer);
-    #else
-        snd_pcm_indirect_playback_transfer(substream, pcm_indirect, mr_alsa_audio_pcm_playback_ack_transfer);
-        return 0;
-    #endif
-    }
-    else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
-    {
-        struct snd_pcm_indirect *pcm_indirect = &chip->pcm_capture_indirect;
-    #if LINUX_VERSION_CODE >= KERNEL_VERSION(5,2,0)
-        return snd_pcm_indirect_capture_transfer(substream, pcm_indirect, mr_alsa_audio_pcm_capture_ack_transfer);
-    #else
-        snd_pcm_indirect_capture_transfer(substream, pcm_indirect, mr_alsa_audio_pcm_capture_ack_transfer);
-        return 0;
-    #endif
-    }
-    return 0;
-}
 
 /// hw_params callback
 /// This is called when the hardware parameter (hw_params) is set up by the application, that is, once when
@@ -2347,16 +1844,7 @@
     .prepare =  mr_alsa_audio_pcm_prepare,
     .trigger =  mr_alsa_audio_pcm_trigger,
     .pointer =  mr_alsa_audio_pcm_pointer,
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,13,0)
-    .copy_user = mr_alsa_audio_pcm_playback_copy_user,
-    //.copy_kernel = mr_alsa_audio_pcm_playback_copy,
-    .fill_silence = mr_alsa_audio_pcm_playback_fill_silence,
-#else
-    .copy =     mr_alsa_audio_pcm_playback_copy,
-    .silence =  mr_alsa_audio_pcm_playback_silence,
-#endif
     .page =     snd_pcm_lib_get_vmalloc_page,
-    .ack =      mr_alsa_audio_pcm_ack,
 };
 
 /////////////////////////////////////////////////////////////////////////////////////
@@ -2369,16 +1857,7 @@
     .prepare =  mr_alsa_audio_pcm_prepare,
     .trigger =  mr_alsa_audio_pcm_trigger,
     .pointer =  mr_alsa_audio_pcm_pointer,
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,13,0)
-    .copy_user = mr_alsa_audio_pcm_capture_copy_user,
-    //.copy_kernel = mr_alsa_audio_pcm_capture_copy,
-    .fill_silence = NULL,
-#else
-    .copy =     mr_alsa_audio_pcm_capture_copy,
-    .silence =  NULL, //mr_alsa_audio_pcm_silence,
-#endif
     .page =     snd_pcm_lib_get_vmalloc_page,
-    .ack =      mr_alsa_audio_pcm_ack,
 };
 
 

