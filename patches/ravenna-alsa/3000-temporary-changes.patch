2021-02-16 current test and debug code in PTP.c and module_timer.c

--- a/driver/PTP.c
+++ b/driver/PTP.c
@@ -49,8 +49,8 @@
 #define TIC_LOCK_HYSTERESIS		5
 
 //REF_UNIT is cent of microseconde (100us)
-#define PS_2_REF_UNIT 100000000 // ps is the PTP unit
-#define NS_2_REF_UNIT 100000 // ns is the linux time unit
+#define PS_2_REF_UNIT 10000000 // ps is the PTP unit
+#define NS_2_REF_UNIT 10000 // ns is the linux time unit
 
 // PTP Domain
 #define PTPMASTER_ANNOUNCE_TIMEOUT	50000000 // [100ns]
@@ -848,20 +848,21 @@
     return &self->m_csSAC_Time_Lock;
 }*/
 
-
 ///////////////////////////////////////////////////////////////////////////////
 void computeNextAbsoluteTime(TClock_PTP* self, uint32_t ui32FrameCount)
 {
 	uint64_t ui64Period = self->m_dTIC_CurrentPeriod / PS_2_REF_UNIT; // [ps -> 100us]
+	uint64_t ui64Fraction = CW_ll_modulo(self->m_dTIC_CurrentPeriod, PS_2_REF_UNIT); // [ps -> 100us]
 
 	self->m_ui64TIC_NextAbsoluteTime += ui64Period * ui32FrameCount;
-	self->m_dTIC_NextAbsoluteTime_frac += CW_ll_modulo(self->m_dTIC_CurrentPeriod, PS_2_REF_UNIT) * ui32FrameCount;
+	self->m_dTIC_NextAbsoluteTime_frac += ui64Fraction * ui32FrameCount;
 	if (self->m_dTIC_NextAbsoluteTime_frac > PS_2_REF_UNIT)
 	{
-		uint32_t ui32EpsilonCount = (uint32_t)(self->m_dTIC_NextAbsoluteTime_frac) / PS_2_REF_UNIT;
-		self->m_dTIC_NextAbsoluteTime_frac -= PS_2_REF_UNIT * ui32EpsilonCount;
-		self->m_ui64TIC_NextAbsoluteTime += ui32EpsilonCount;
-	}
+		self->m_dTIC_NextAbsoluteTime_frac -= PS_2_REF_UNIT;
+		self->m_ui64TIC_NextAbsoluteTime += 1;
+	}
+    if( self->m_dTIC_NextAbsoluteTime_frac > PS_2_REF_UNIT )
+        MTAL_DP_WARN("computeNextAbsoluteTime: residue %lld\n", self->m_dTIC_NextAbsoluteTime_frac / PS_2_REF_UNIT);
 
 	/* Orignial code with a loop :
 	uint64_t ui64Period = self->m_dTIC_CurrentPeriod / PS_2_REF_UNIT; // [ps -> 100us]
--- a/driver/module_timer.c
+++ b/driver/module_timer.c
@@ -48,20 +48,29 @@
 static uint64_t timer_resolution;
 static int stop_;
 
+static uint64_t last_wakeup = 0;
+
+static uint64_t ui = 0;
+static uint64_t uip0;
+static uint64_t uip1;
+static uint64_t uip2;
+
 #define NS_TO_100US(x) ((x) / 100000ULL)
 
 enum hrtimer_restart timer_callback(struct hrtimer *timer)
 {
     int ret_overrun;
     ktime_t period;
-    uint64_t next_wakeup;
+    ktime_t next_wakeup;
     uint64_t now;
+    uint64_t ui64Period;
 
     do
     {
         t_clock_timer(&next_wakeup);
         get_clock_time(&now);
-        period = ktime_set(0, next_wakeup - now);
+        ui64Period = next_wakeup - now;
+        period = ktime_set(0, ui64Period);
 
         if (now > next_wakeup || next_wakeup - now < timer_resolution)
         {
@@ -71,7 +80,7 @@
         else if (ktime_to_ns(period) > max_period_allowed || ktime_to_ns(period) < min_period_allowed)
         {
             MTAL_DP_DEBUG("Timer period out of range: %lld [100 us]. Target period = %lld [100 us]\n", NS_TO_100US(ktime_to_ns(period)), NS_TO_100US(base_period_));
-            if (ktime_to_ns(period) > (unsigned long)5E9L)
+            if (ktime_to_ns(period) > (unsigned long)1E9L)
             {
                 MTAL_DP_DEBUG("Timer period greater than 5s, set it to 1s!\n");
                 period = ktime_set(0,((unsigned long)1E9L)); //1s
@@ -85,11 +94,35 @@
     }
     while (ktime_to_ns(period) == 0); // this able to be rarely true
 
-    ret_overrun = hrtimer_forward_now(timer, period);
+#if 0
+    {
+        if( last_wakeup == 0 ) {
+            last_wakeup = now;
+            uip2 = uip1 = uip0 = base_period_;
+        }
+        // current period falls into two segments
+        uint64_t uipa = now>last_wakeup?now-last_wakeup:0;
+        uint64_t uipb = next_wakeup>now?next_wakeup-now:0;
+        // PID for period time
+        ui64Period = next_wakeup - last_wakeup;
+        ui64Period = (500 * ui64Period + 300 *uip1 + 200 * uip2) / 1000;
+        uip2 = uip1;
+        uip1 = uip0;
+        uip0 = ui64Period;
+        last_wakeup = next_wakeup;
+        if (++ui % 1000 == 0)
+            //MTAL_DP_WARN("timer_callback: p0 %llu p1 %llu p2 %llu a %llu b %llu\n", uip0, uip1, uip2, uipa, uipb);
+            MTAL_DP_WARN("timer_callback: lst %llu now %llu nxt\n", last_wakeup/1000ULL, now/1000ULL, next_wakeup/1000ULL);
+        if( ui64Period > uipa)
+            period = ktime_set(0, ui64Period - uipa);
+    }
+#endif
+
+    ret_overrun = hrtimer_forward(timer, now, period);
     // only warn for completely lost periods
 	// the 50% overrun is monitored in timerProcess() 
     if(unlikely(ret_overrun && ktime_to_ns(period) * ret_overrun > base_period_ * 2))
-        MTAL_DP_INFO("Timer overrun ! (%d frames)\n", (int) (ktime_to_ns(period) * ret_overrun / base_period_));
+        MTAL_DP_DEBUG("Timer overrun ! (%d frames)", (int) (ktime_to_ns(period) * ret_overrun / base_period_));
 
     return HRTIMER_RESTART;
 }
@@ -98,7 +131,7 @@
 {
     stop_ = 0;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5,2,0)
-    hrtimer_init(&my_hrtimer_, CLOCK_MONOTONIC, HRTIMER_MODE_ABS_SOFT);
+    hrtimer_init(&my_hrtimer_, CLOCK_MONOTONIC, HRTIMER_MODE_REL_SOFT);
     my_hrtimer_.function = &timer_callback;
 #else
     tasklet_hrtimer_init(&my_hrtimer_, timer_callback, CLOCK_MONOTONIC/*_RAW*/, HRTIMER_MODE_PINNED/*HRTIMER_MODE_ABS*/);
@@ -120,12 +153,12 @@
 int start_clock_timer(void)
 {
     ktime_t period = ktime_set(0, base_period_); //100 ms
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,2,0)
-    hrtimer_start(&my_hrtimer_, period, HRTIMER_MODE_ABS);
-#elif LINUX_VERSION_CODE >= KERNEL_VERSION(4,16,0)
-    tasklet_hrtimer_start(&my_hrtimer_, period, HRTIMER_MODE_ABS_SOFT);
-#else
-    tasklet_hrtimer_start(&my_hrtimer_, period, HRTIMER_MODE_ABS);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,2,0) // tasklet code deprecated
+    hrtimer_start(&my_hrtimer_, period, HRTIMER_MODE_REL_SOFT);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(4,16,0) // integrated soft interrupt context
+    tasklet_hrtimer_start(&my_hrtimer_, period, HRTIMER_MODE_REL_SOFT);
+#else // soft interrupt context provided by tasklet
+    tasklet_hrtimer_start(&my_hrtimer_, period, HRTIMER_MODE_REL);
 #endif
 
     return 0;
